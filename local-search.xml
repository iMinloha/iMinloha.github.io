<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>幻想在娱乐作品中举足轻重</title>
    <link href="/2022/08/11/%E8%B0%88%E8%B0%88%E5%9B%BD%E6%BC%AB/"/>
    <url>/2022/08/11/%E8%B0%88%E8%B0%88%E5%9B%BD%E6%BC%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>我也不算阅片无数，只能说比较善于感悟，一些比较出名的动漫或者小说也都有看，在阅读这些作品的内容以及分析作者部分社会背景我才有较大的自信发出此博客。我并不是通过贬低其他人来抬高自己，我也是有情欲的人，也会做出相似的幻想。</p><p>在我看来所谓喜欢的影视作品，无非就是某些要素满足了观众的想法，比如某剧有帅气的小哥哥、好看的小姐姐对观众的胃口，观众就会喜欢，这也是很多导演拍剧要考虑的要素。如果抛弃外观谈灵魂，如果一部小说希望得到读者的喜欢，那么它应该怎么做？很简单，找到大众喜欢的口味，那这种口味到底是什么呢？</p><p>其实答案很简单，作品的味道表达的就是作者的幻想。如果一个人热血但是无处施展，那么他一定会去接触热血的作品。同理，如果一个单身狗想脱单但是长时间找不到心仪的女方，那他会有很大概率会喜欢恋爱相关的作品。当然这些喜欢可能会根据人状态的改变而改变，铁树总能开花的。</p><p>所以从一个人阅读的内容中就可以看出一个人的幻想的是什么，当然肯定会有超凡脱俗、无欲无求的人不满足我所述的现象的哈！</p><hr><p>反过来也是适用的，作者在创造作品时肯定会融入自己的元素，但并不是所有元素都能被作者第一时间想到，更多的还是作者本人的幻想，而作品经过融入作者思想后，显然能让作者的幻想外显。所以一部作品中通常包含了作者很多幻想，就比如一个中二病时期的学生所写的作品一定不会逃离校园的各种对作者很爽的事，像是“恶霸围堵被我反杀”、“漂亮妹子竟是我女友”、“一向废柴的我获得改变世界的能力”等等，都可能出现。那也就能看出作品直接反应了作者本人的想法，一般在单人创作的作品对这些要素是完美体现的（因为团队写书需要融合很多人的思想）</p><p>通过上文我们可以看到幻想是作品创作的灵魂、是读者与作品产生共鸣的接触点，那么所谓“正因为无法实现,所以才放入影视作品”的含义就不难理解，影视作品通常都是一些美好的幻想，但是这些幻想的实现较为困难以至于无法实现。常见的都市爱情，通常男女主关系都是满足“霸道总裁爱上我”、“一见钟情”，或者龙傲天故事都包含退婚、获得能力、回头打脸。这些类型的作品都表达了作者最直接的幻想。但从理性的角度，在现实不可能会出现这些情况，因为人也是很忙的，换句话说，高速的时代让大多数人们无法获得切实的美好体验，所以影视作品将这些美好体验放进去，让其变成和观众的接触点。</p><p>当然，人们的幻想不仅体现在影视作品上，任何起到娱乐作用的事物都有体现，如今自媒体时代高速发展，幻想的种类越来越多样，能分清这些幻想并能利用这些幻想的人，往往都能火。如果你想了解一个人，通过他所看的作品也能清楚的知道他的幻想是什么，至于观察的方法就是社会经验问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我主要描述了幻想在作品中的地位以及在人与艺术中幻想的作用，证明了“正因为无法实现,所以才放入影视作品”的正确性</p>]]></content>
    
    
    <categories>
      
      <category>娱乐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>三观</tag>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随机数怎么样随机的</title>
    <link href="/2022/08/02/%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <url>/2022/08/02/%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>都说计算机的随机都是伪随机，其实无论是生活的各个角落都是伪随机而不是真随机，真随机可能真的不存在，所有的事件都可以用简单的P(A)表示，无论是否有条件，那么我们如果实现这种随机呢？</p><h2 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h2><p>随机数对人来说可能是随机的也可能不是，处于量子态，不过目前的计算机所生成的随机数其实不算真随机，而是一种周期很大的循环数，那这样的数怎么生成呢？</p><h3 id="线性同余法-LCG"><a href="#线性同余法-LCG" class="headerlink" title="线性同余法[LCG]"></a>线性同余法[LCG]</h3><p>这种方法较为常用，在《C primer plus》中介绍了一段魔术语句，可以实现随机数，那么很多人可能好奇为什么这串代码可以生成随机数，这些已知的数字都是什么含义等等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">m_rand</span><span class="hljs-params">(<span class="hljs-keyword">int</span> seed)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">214013</span>*seed+<span class="hljs-number">2531011</span>)&gt;&gt;<span class="hljs-number">16</span>&amp;((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>)<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>其实学过数学的人都对这种Ax+B的格式不陌生，一般都以线性开头命名，即线性同余算法，这种算法用通式表示为：</p><script type="math/tex; mode=display">seed = (A * seed + B) \% C</script><p>其中最大周期为C，A、B均为整数且C的所有因数中的质数都可以被A-1整除，即满足C%(A-1)==0</p><p>对于A、B是经过计算得到的，通过移位运算不难算出重复周期为2^15-1即(1&lt;&lt;15)-1。代码中的种子常使用时间。在C++的Random头文件中使用了这种算法。</p><p><img src="http://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/random/1.png" alt="1"></p><h3 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h3><p>这个算法的爹是冯诺依曼，算法主要讲的是：给定一个m位数记作x，其中m是偶数（基数计算带分数），计算x的平方，得到2m位数（不足在首端补0）然后从乘数中间得到m位数，然后重复这一步骤。</p><h3 id="梅森旋转-Mersenne-Twister-算法"><a href="#梅森旋转-Mersenne-Twister-算法" class="headerlink" title="梅森旋转(Mersenne Twister)算法"></a>梅森旋转(Mersenne Twister)算法</h3><p>衡量梅森旋转(MT)的质量，需要使用K分布，K分布的定义是：一个周期为T的随机序列Xi，每一位都有w位，当满足下面条件就成为w位的K分布</p><blockquote><p>假设f(x)表示x的前v位形成的数字，并且长度为P的kv位序列：</p><p>($f(x<em>i)$，$f(x</em>{i+1})$，$f(x<em>{i+2})$…….$f(x</em>{i+k-1})$)</p><p>其中每个可能出现的$2^{kv}$组合在一个周期内出现相同的次数（除全0序列出现次数次数比其他序列少1次）</p></blockquote><p>算法需要借助线性反馈移位寄存器(LFSR)生成随机数，主要使用的运算符是异或(xor)，我们采用8位寄存器的形式演示，初始化寄存器位10001010，然后定义反馈函数为：</p><script type="math/tex; mode=display">x^8+x^4+x^2+1</script><p>所以我们根据x的重数可知，只需对第8、4、2、1按顺序做一次异或即可。然后丢掉最后一位，把当前结果插入首端。然后循环这个过程多次，就得到了随机序列。这便是旋转的过程。</p><p><img src="http://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/random/2.png" alt="2"></p><p>我们使用C++实现这个过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 十进制转二进制</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">DextoBin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; bincode;<br>    <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)&#123;<br>        bincode.<span class="hljs-built_in">push_back</span>(num % <span class="hljs-number">2</span>);<br>        num /= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bincode;<br>&#125;<br><span class="hljs-comment">// 二进制转十进制</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BintoDex</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; arr)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> dex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; n &lt; arr.<span class="hljs-built_in">size</span>(); n++) &#123;<br>        <span class="hljs-keyword">int</span> t = arr.<span class="hljs-built_in">size</span>() - n - <span class="hljs-number">1</span>;<br>        dex += (arr[n] &lt;&lt; t);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dex;<br>&#125;<br><span class="hljs-comment">// 移位</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">moveBack</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr,<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = arr.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>; it != arr.<span class="hljs-built_in">end</span>();it++) &#123;<br>        *it -= <span class="hljs-number">1</span>;<br>    &#125;<br>    arr[<span class="hljs-number">0</span>] = num;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-comment">// 生成MT数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MT_random</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; bin = <span class="hljs-built_in">DextoBin</span>(num);<br>    <span class="hljs-keyword">if</span> (bin.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) bin.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 取得反馈函数的最高次</span><br>    <span class="hljs-keyword">while</span> ((bin.<span class="hljs-built_in">size</span>() - (<span class="hljs-number">2</span> &lt;&lt; m<span class="hljs-number">-1</span>)) &gt; bin.<span class="hljs-built_in">size</span>() - (<span class="hljs-number">2</span> &lt;&lt; m)) m++;<br>    <span class="hljs-keyword">for</span> (; m == <span class="hljs-number">1</span>; m /= <span class="hljs-number">4</span>) p = bin[m] ^ bin[m &gt;&gt; <span class="hljs-number">2</span>];<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res = <span class="hljs-built_in">moveBack</span>(bin,p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">BintoDex</span>(res);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 设置循环次数</span><br>    <span class="hljs-keyword">int</span> time = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (time &gt; <span class="hljs-number">1</span>) cout&lt;&lt; <span class="hljs-built_in">MT_random</span>(<span class="hljs-number">123</span>) &lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过修改传递的MT_random参数就可以得到不同的随机数</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过阅读本文，读者可以了解随机数生成的基本过程，也能了解背后的理论基础，同时对MT算法可以深入理解。</p><p>MT算法部分参考：</p><p><a href="https://en.wikipedia.org/wiki/Mersenne_Twister">https://en.wikipedia.org/wiki/Mersenne_Twister</a></p><p><a href="https://www.freesion.com/article/8091743663/">https://www.freesion.com/article/8091743663/</a></p>]]></content>
    
    
    <categories>
      
      <category>学业，技术，娱乐，新事物，笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于我在填报志愿时使用的妙法</title>
    <link href="/2022/07/25/%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2022/07/25/%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="收集数据"><a href="#收集数据" class="headerlink" title="收集数据"></a>收集数据</h2><p>要知道要想分析，首先应该有数据，你可以在百度或者其他搜索引擎上搜索到高考相关信息，非常便捷，一般在填报志愿时一本分数线都会知道，不知道也没关系，无非是少了一份数据。</p><p>这里我以黑龙江5年内一本分数线举例，我们先定义出我们的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> pylab <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> scipy.optimize <span class="hljs-keyword">import</span> leastsq<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment"># 年份</span><br>data = np.array([<span class="hljs-number">2018</span>,<span class="hljs-number">2019</span>,<span class="hljs-number">2020</span>,<span class="hljs-number">2021</span>])<br>data2 = np.array([<span class="hljs-number">2017</span>,<span class="hljs-number">2018</span>,<span class="hljs-number">2019</span>,<span class="hljs-number">2020</span>,<span class="hljs-number">2021</span>])<br><span class="hljs-comment"># 目标学校录取分数（专业线或者投档线都可以）</span><br>score = np.array([<span class="hljs-number">500</span>,<span class="hljs-number">514</span>,<span class="hljs-number">500</span>,<span class="hljs-number">455</span>])<br><span class="hljs-comment"># 一本线</span><br>line = np.array([<span class="hljs-number">455</span>,<span class="hljs-number">472</span>,<span class="hljs-number">477</span>,<span class="hljs-number">455</span>,<span class="hljs-number">415</span>])<br><br><span class="hljs-comment"># 如果出现了当年的一本线,则补全</span><br>lline = np.array([<span class="hljs-number">455</span>,<span class="hljs-number">472</span>,<span class="hljs-number">477</span>,<span class="hljs-number">455</span>,<span class="hljs-number">415</span>,<span class="hljs-number">429</span>])<br><span class="hljs-comment"># 年份</span><br>ldata = np.array([<span class="hljs-number">2017</span>,<span class="hljs-number">2018</span>,<span class="hljs-number">2019</span>,<span class="hljs-number">2020</span>,<span class="hljs-number">2021</span>,<span class="hljs-number">2022</span>])<br></code></pre></td></tr></table></figure><h2 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h2><p>收集完分数后我们先绘制一下学校录取线关于年份的散点图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">6</span>))<br>    <span class="hljs-comment"># 如果你不知道一本线可以绘制一本线的图形</span><br>    <span class="hljs-comment">#plt.scatter(data, line, color=&quot;green&quot;, label=&quot;Data analysis&quot;, linewidth=2)</span><br>    plt.scatter(data, score, color=<span class="hljs-string">&quot;green&quot;</span>, label=<span class="hljs-string">&quot;Data analysis&quot;</span>, linewidth=<span class="hljs-number">2</span>)<br>    plt.xlim(<span class="hljs-number">2017</span>,<span class="hljs-number">2022</span>)<br>    plt.show()<br></code></pre></td></tr></table></figure><p>我们看到散点的走势先增后减，所以我们要用二次函数去拟合它，我们选择使用最小二乘法求参数，所以我们先抽象出函数的形式。</p><p><img src="http://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/data_analysis/1.png" alt="1"></p><p>抽象函数我们需要使用一个能直接返回函数值的python函数和计算参数的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算值的函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">norfun</span>(<span class="hljs-params">params,x</span>):</span><br>    a,b,c=params<br>    <span class="hljs-keyword">return</span> a*x*x+b*x+c<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">error</span>(<span class="hljs-params">params,x,y</span>):</span><br>    <span class="hljs-keyword">return</span> norfun(params,x)-y<br><br><span class="hljs-comment"># 计算参数的函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sloveParam</span>():</span><br>    p0 = [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>]<br>    <span class="hljs-comment"># Param计算出了data为x、score为y的二次函数拟合参数</span><br>    Param = leastsq(error, p0, args=(data, score))<br>    <span class="hljs-keyword">return</span> Param<br></code></pre></td></tr></table></figure><p>然后我们在main函数内加入二次函数，绘制出拟合曲线：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    Param = sloveParam()<br>    a, b, c = Param[<span class="hljs-number">0</span>]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;y=&quot;</span>+<span class="hljs-built_in">str</span>(<span class="hljs-built_in">round</span>(a,<span class="hljs-number">2</span>))+<span class="hljs-string">&quot;x*x+&quot;</span>+<span class="hljs-built_in">str</span>(<span class="hljs-built_in">round</span>(b,<span class="hljs-number">2</span>))+<span class="hljs-string">&quot;x+&quot;</span>+<span class="hljs-built_in">str</span>(c))<br><br>    plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">6</span>))<br>    plt.scatter(data, score, color=<span class="hljs-string">&quot;green&quot;</span>, label=<span class="hljs-string">&quot;Data analysis&quot;</span>, linewidth=<span class="hljs-number">2</span>)<br>    plt.xlim(<span class="hljs-number">2017</span>,<span class="hljs-number">2022</span>)<br>    <span class="hljs-comment">## plt.ylim(400,550)</span><br><br>    x=np.linspace(<span class="hljs-number">2017</span>,<span class="hljs-number">2022</span>,<span class="hljs-number">100</span>) <span class="hljs-comment">##在2017-2022这15年间直接画100个点,也可以向后修改年份</span><br>    y=a*x*x+b*x+c <span class="hljs-comment">##函数式</span><br>    plt.plot(x,y,<span class="hljs-string">&quot;ro-&quot;</span>)<br>    plt.legend()<br>    plt.show()<br></code></pre></td></tr></table></figure><p>我们看一下拟合曲线可以发现，拟合效果非常好，可以我们看到右下角我们要预测的值很离谱，只有380.8是不是意味着我们稳了呢？并不是，其实是我们在计算拟合曲线出错了，原因很简单，我们没有加入所有影响数据的变量，最重要的就是变量line，因为它的波动直接影响了拟合曲线，所以我们要使用的纵轴值应该时score-line。</p><p><img src="http://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/data_analysis/2.png" alt="2"></p><h2 id="结论与源码"><a href="#结论与源码" class="headerlink" title="结论与源码"></a>结论与源码</h2><p>最后我们把成品代码发一下，绘制出差值拟合图，最后我们得到学校和一本线的差距是多少</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> pylab <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> scipy.optimize <span class="hljs-keyword">import</span> leastsq<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 年份</span><br>data = np.array([<span class="hljs-number">2018</span>,<span class="hljs-number">2019</span>,<span class="hljs-number">2020</span>,<span class="hljs-number">2021</span>])<br>data2 = np.array([<span class="hljs-number">2017</span>,<span class="hljs-number">2018</span>,<span class="hljs-number">2019</span>,<span class="hljs-number">2020</span>,<span class="hljs-number">2021</span>])<br><span class="hljs-comment"># 目标学校录取分数（专业线或者投档线都可以）</span><br>score = np.array([<span class="hljs-number">500</span>,<span class="hljs-number">514</span>,<span class="hljs-number">500</span>,<span class="hljs-number">455</span>])<br><span class="hljs-comment"># 一本线</span><br>line = np.array([<span class="hljs-number">455</span>,<span class="hljs-number">472</span>,<span class="hljs-number">477</span>,<span class="hljs-number">455</span>,<span class="hljs-number">415</span>])<br><br><span class="hljs-comment"># 如果出现了当年的一本线,则补全</span><br>lline = np.array([<span class="hljs-number">455</span>,<span class="hljs-number">472</span>,<span class="hljs-number">477</span>,<span class="hljs-number">455</span>,<span class="hljs-number">415</span>,<span class="hljs-number">429</span>])<br><span class="hljs-comment"># 年份</span><br>ldata = np.array([<span class="hljs-number">2017</span>,<span class="hljs-number">2018</span>,<span class="hljs-number">2019</span>,<span class="hljs-number">2020</span>,<span class="hljs-number">2021</span>,<span class="hljs-number">2022</span>])<br><br><span class="hljs-comment"># 计算值的函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">norfun</span>(<span class="hljs-params">params,x</span>):</span><br>    a,b,c=params<br>    <span class="hljs-keyword">return</span> a*x*x+b*x+c<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">error</span>(<span class="hljs-params">params,x,y</span>):</span><br>    <span class="hljs-keyword">return</span> norfun(params,x)-y<br><br><span class="hljs-comment"># 计算参数的函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sloveParam</span>():</span><br>    p0 = [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>]<br>    <span class="hljs-comment"># Param计算出了data为x、score为y的二次函数拟合参数</span><br>    Param = leastsq(error, p0, args=(data, score))<br>    <span class="hljs-keyword">return</span> Param<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    Param = sloveParam()<br>    a, b, c = Param[<span class="hljs-number">0</span>]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;y=&quot;</span>+<span class="hljs-built_in">str</span>(<span class="hljs-built_in">round</span>(a,<span class="hljs-number">2</span>))+<span class="hljs-string">&quot;x*x+&quot;</span>+<span class="hljs-built_in">str</span>(<span class="hljs-built_in">round</span>(b,<span class="hljs-number">2</span>))+<span class="hljs-string">&quot;x+&quot;</span>+<span class="hljs-built_in">str</span>(c))<br><br>    plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">6</span>))<br>    plt.scatter(data, score-line, color=<span class="hljs-string">&quot;green&quot;</span>, label=<span class="hljs-string">&quot;Data analysis&quot;</span>, linewidth=<span class="hljs-number">2</span>)<br>    plt.xlim(<span class="hljs-number">2017</span>,<span class="hljs-number">2022</span>)<br>    <span class="hljs-comment">## plt.ylim(400,550)</span><br><br>    x=np.linspace(<span class="hljs-number">2017</span>,<span class="hljs-number">2022</span>,<span class="hljs-number">100</span>) <span class="hljs-comment">##在2017-2022这15年间直接画100个点,也可以向后修改年份</span><br>    y=a*x*x+b*x+c<br>    plt.plot(x,y,<span class="hljs-string">&quot;ro-&quot;</span>)<br>    plt.legend()<br>    plt.show()<br></code></pre></td></tr></table></figure><p><img src="http://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/data_analysis/3.png" alt="3"></p><p>差值为30.89，如果预测了当年的一本线可以进行加和，如果已知那就更好了，我们是429分，我们对30.89进行四舍五入就是31，加和为460分。</p><blockquote><p> 据私下咨询招生办了解，当年的分数线是461分，误差很小了</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大数据的角度，数据之间都是有规律的，但正因为有人去发现与研究，这项技术才越发的实用，在这里预祝后来者们都能考上自己喜欢的大学，被喜欢的专业录取！</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>数学</tag>
      
      <tag>数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>说说最近的情况</title>
    <link href="/2022/07/24/%E6%9C%80%E8%BF%91%E5%9C%A8%E5%B9%B2%E5%98%9B/"/>
    <url>/2022/07/24/%E6%9C%80%E8%BF%91%E5%9C%A8%E5%B9%B2%E5%98%9B/</url>
    
    <content type="html"><![CDATA[<h2 id="最近在忙的"><a href="#最近在忙的" class="headerlink" title="最近在忙的"></a>最近在忙的</h2><p>最近嘛，不是刚刚高考完嘛，虽然本人高考成绩不算出众，在文科方面确实差了一些，但是都是我自己学出来的也就没有什么后悔的。今年黑龙江一本线是429，我考了454，在小县城的普通高中，感觉还不错。</p><p>回到主线，因为这个分数比较尴尬吧，不能走出省，也就只能在当地找一个比较好的大学读着（等到考研时在南下吧），所以就选学校选了好久。写完志愿后又忙着学After Effect做特效啥的，也弄了好久。头些日子电脑又出问题，我又重装了一下系统。</p><p>在一切破事完成后，我就开始学习了，我主要完成了线性代数部分的内容以及精通一下C和C++，</p><p>前一周吧，因为时间稍微款搜了哈，就鼓捣鼓捣博客的CDN，结果不小心给对象存储删除了，没办法呀，也没有备份，又花了一点时间从腾讯的对象存储换到阿里云的（阿里云的性价比挺高）</p><p>这一周吧，忽然有了一个想法，打算写一篇研究报告当毕业设计了，就是关于《JDK源码阅读理解底层实现》，我查阅了一下发现百度上并没有关于AOT对Java的预热原理，所以我就创新的完成啦！</p><h2 id="现在的实力"><a href="#现在的实力" class="headerlink" title="现在的实力"></a>现在的实力</h2><div class="table-container"><table><thead><tr><th>技术</th><th>能力值(10)</th></tr></thead><tbody><tr><td>C/C++</td><td>7</td></tr><tr><td>Java</td><td>8</td></tr><tr><td>Python</td><td>5</td></tr><tr><td>Html/Css/Javascript</td><td>6</td></tr><tr><td>Mysql/Redis</td><td>6</td></tr><tr><td>UI设计</td><td>4</td></tr><tr><td>高等数学</td><td>6</td></tr><tr><td>线性代数</td><td>6.5</td></tr><tr><td>算法</td><td>7.5</td></tr><tr><td>离散数学</td><td>10</td></tr><tr><td>深度学习</td><td>3</td></tr></tbody></table></div><h2 id="发展方向"><a href="#发展方向" class="headerlink" title="发展方向"></a>发展方向</h2><p>这应该算是一个阶段的展望吧，我个人是比较希望向深度学习神经网络或者算法工程师这方面发展的，不过我还是喜欢偏向理论研究的。</p><p>目前最想做的事情就是静下心能有个好地方让我认认真真的研究计算机，所以我就寄希望于大学的计算机科学院了……</p><p>最近主要在Qt方面下功夫，因为我除了Html就没有什么拿得出手的UI能力了…..</p><p>至于博客这里我肯定还会继续做的，而且我还要做的更好，这点毋庸置疑。</p>]]></content>
    
    
    <categories>
      
      <category>娱乐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新鲜事</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECC纠错的原理</title>
    <link href="/2022/07/11/ECC%E7%BA%A0%E9%94%99/"/>
    <url>/2022/07/11/ECC%E7%BA%A0%E9%94%99/</url>
    
    <content type="html"><![CDATA[<h1 id="ECC内存条"><a href="#ECC内存条" class="headerlink" title="ECC内存条"></a>ECC内存条</h1><p>内存条属于RAM，在电脑每次启动运行时，内存读取硬盘数据保存并便于CPU使用，但是在读取过程中因为存在电子干扰，所以对于载流子传递过程中可能会有点位的变化，也就是正电变负电等等，二进制中就是1变成0，或者0变成1，在宇宙射线较强或者人工电子仪器过多的地方，计算机对读取过程精度要求较高，所以需要在读取过程进行主动的纠错，那都有什么方法纠错呢？</p><h2 id="三遍传输"><a href="#三遍传输" class="headerlink" title="三遍传输"></a>三遍传输</h2><p>如何进行纠错呢？一般通过把数据同时传输三次，如果出现不同，则相互比较替换，比如我传输:11001011001</p><p>假设它发生了错误，变成了11001111001，我们把错误和其他两次传输内容比较，很容易就找出并改正错误，但也就有一个问题，如果我的数据量很大，那就要牺牲内存2/3的区域用于存储这些进行纠错的编码（纠错码）所以这种方法的缺点就是对内存的利用率偏低。</p><h2 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h2><p>通过统计一段二进制码中1的基偶数，判断数据是否被修改。通常加入一位纠错码，比如11001011001，我们看到有6个1，也就是偶数个，那么我们在最前面加上0作为纠错码，这样二进制总体的基偶数并没有改变。也就是011001011001，如果在传输过程中改变任何一位，基偶性就会改变。</p><p>但是知道了改变却不知道哪里改变，所以只能重新发送一遍（🤔）比较浪费资源</p><h2 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h2><p>我们在线性代数和离散数学中学过邻接矩阵，如果我们把传输数据折叠为邻接矩阵呢？我们先假设数据内容够我们折叠为4×4方阵。假设数据为1100|1010|1001|1011</p><script type="math/tex; mode=display">\left[\begin{matrix}1&1&0&0\\1&0&1&0\\1&0&0&1\\1&0&1&0\\\end{matrix} \right]</script><p>我们横向折叠的原因是，如果我们把每一位都用二进制形式表示，那么邻接矩阵的位数二进制就是：</p><div class="table-container"><table><thead><tr><th><strong>0000</strong></th><th style="text-align:center"><strong>0001</strong></th><th>0010</th><th>0011</th></tr></thead><tbody><tr><td><strong>0100</strong></td><td style="text-align:center">0101</td><td><strong>0110</strong></td><td>0111</td></tr><tr><td><strong>1000</strong></td><td style="text-align:center">1001</td><td>1010</td><td><strong>1011</strong></td></tr><tr><td><strong>1100</strong></td><td style="text-align:center">1101</td><td><strong>1110</strong></td><td>1111</td></tr></tbody></table></div><p>我们看到每一列都是具有规律的。我们把列的倒数第一位为1的几位C1组，倒数第二位记为C2组，相似的，行正数第三位为1的记为L1，行第一位为1的记为L2。结合容斥原理，我们只需统计各组内1的基偶就能定位出传输错误的位置了！</p><p>如果你学过数字电路技术，哪怕是群论的布尔运算，我们都能知道，统计数字对电路很难但逻辑运算对电路很简单，所以我们用哪种运算符可以发现变化位置呢？答案是异或，即不同为1相同为0，我们把上面的矩阵改个数字。</p><script type="math/tex; mode=display">\left[\begin{matrix}1&1&0&0\\1&0&1&0\\0&0&0&1\\1&0&1&0\\\end{matrix} \right]</script><p>我们把1的位置都统计出来。</p><p>0000，0001，0100，0110，1011，1100，1110。我们按位异或，得到结果为1000，这个结果恰好是我们改动的位置。这不是偶然而是必然，原理就是：</p><p>当传递数据中1的个数是基数个时，无论怎么运算，总会出现位数为1，而原数据1的个数是偶数，无论怎么运算，都只会是0000，这也是邻接矩阵的二进制性质。</p><p>至于如何保证原数据1的个数是偶数，我们只要让邻接矩阵一行和一列修改就可以，而每位都是2的整数次幂，实现过程只需要像C语言的”&gt;&gt;”进行一次移位就可以了。</p><h2 id="LDPC编码"><a href="#LDPC编码" class="headerlink" title="LDPC编码"></a>LDPC编码</h2><blockquote><p>这部分会有难度，小心！</p></blockquote><p>LDPC主要应用于固态硬盘读取过程中的纠错，他的全名是：Low Density Parity Check Code，中文名：低密度奇偶校验码.</p><p>首先我们引入，如果n位是有效的数据位为信息位，码字总长位m(m&gt;n)，那么监督位就是剩下的m-n位，因为LDPC编码能够逼近香农编码极限………</p><p>信息论没学过？香农极限表达式不知道？没事，我告诉你，香农第二定理就是我们要的：</p><script type="math/tex; mode=display">C=Blog\,(1+\frac{S}{N})</script><p>其中C表示信道容量，B为信道的宽度，S/N为信噪比，N为噪音。</p><p>信息论完事后就是线性代数：</p><p>我们的LDPC编码本质上是块码，我们假设传递过来的数据是一个向量（只有1和0的向量）记作<strong>D</strong>，我们只要让：</p><script type="math/tex; mode=display">\left(\begin{matrix}0&0&0\end{matrix} \right)^T=D\oplus\left(\begin{matrix}1&0&0&1&0&1\\0&1&0&1&1&1\\0&0&1&0&1&1\\\end{matrix} \right)</script><p>其中令<strong>H</strong>为校验矩阵即：</p><script type="math/tex; mode=display">H=\left(\begin{matrix}1&0&0&0&1&1\\0&1&0&1&1&0\\0&0&1&1&1&1\\\end{matrix} \right)</script><p>校验矩阵虽然看起来比较复杂，但实际上他是Tanner图的邻接矩阵，如果你学过那就会非常好懂，得到LDPC码余下的几位可以用通式表示：</p><script type="math/tex; mode=display">L_i=P_{in}\oplus D_n</script><p>而最后得到的L就是我们的LDPC码，可喜可贺。</p><p>至于H矩阵的求法，结合Tanner图就可以了，如果D的秩为n，那么H秩为n+2。进行运算后就可以了~</p><p>至于使用如果原数据出现任意位的数据改变，就一定不会满足与H运算后仍未0向量。完成了编码，我们尝试一下解码:</p><p>举个解码的例子：</p><h3 id="软解码"><a href="#软解码" class="headerlink" title="软解码"></a>软解码</h3><p>迭代1：第一次信息传递迭代之后，Hard decode解码，此时n0，n4，n6仍为1。</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.co/blog/page/ecc/1.jpg" alt="img"></p><p>迭代2：第二次信息传递迭代之后，Hard decode解码，此时n0仍为1。</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.co/blog/page/ecc/2.jpg" alt="img"></p><p>迭代3：第二次信息传递迭代之后，Hard decode解码，奇偶校验归0。</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.co/blog/page/ecc/3.jpg" alt="img"></p><h3 id="软解码-1"><a href="#软解码-1" class="headerlink" title="软解码"></a>软解码</h3><p>软解码的原理是调整不同read level，根据读取结果后，判断bit是1或者0的概率，然后根据1或者0概率实现软解码, 如下图：</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.co/blog/page/ecc/4.jpg" alt="img"></p><p>LDPC在SSD中的纠错流程如下图所示。值得注意的是，NAND硬判决、数据传输到控制器，以及硬判决解码这几个过程的速度都很快。软判决要读很多次，传输数据很多次，所以会对SSD的性能产生不好的影响。</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.co/blog/page/ecc/5.jpg" alt="img"></p><h2 id="总结与参考"><a href="#总结与参考" class="headerlink" title="总结与参考"></a>总结与参考</h2><p>本文主要列举了ECC纠错使用的编码以及拓展内容固态硬盘的纠错码，通过阅读本文，可以简单了解到基本内容，更深入的希望读者自己发掘！</p><p>本文LDPC部分参考了：(太难了~)</p><p><a href="https://zhuanlan.zhihu.com/p/514670102">https://zhuanlan.zhihu.com/p/514670102</a></p><p><a href="https://blog.csdn.net/ccsss22/article/details/123261025">https://blog.csdn.net/ccsss22/article/details/123261025</a></p><p><a href="https://baijiahao.baidu.com/s?id=1726156569403131467">https://baijiahao.baidu.com/s?id=1726156569403131467</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>吃饭遇到的代数系统</title>
    <link href="/2022/07/01/mathsystem/"/>
    <url>/2022/07/01/mathsystem/</url>
    
    <content type="html"><![CDATA[<h2 id="事故背景"><a href="#事故背景" class="headerlink" title="事故背景"></a>事故背景</h2><p>高考结束后我去饭店吃饭，在饭局上有一个小孩，于是我给他出了一道数学题看看它能不能做出来，但是100以内加减法这种类型的数学题就有些无聊了，所以我们说说代数系统吧！</p><h1 id="代数系统"><a href="#代数系统" class="headerlink" title="代数系统"></a>代数系统</h1><p>我们先来看一下这道简单的题目，我用latex写出来就是：</p><script type="math/tex; mode=display">7+11+11+11=</script><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/mathsystem/1.jpg" alt="事件现场"></p><p>事件现场</p><p>首先我们看出，这是一道基本的计算题，很轻松的就可以算出结果等于40，但是如果你是一个经验丰富的老手，你会选择一个一个进行加和还是有一些简便的运算技巧？我相信你一定是后者吧，我们把11+11+11可以看作3乘11，因为是三个11相加，那么这也有个问题，这个加法式有什么性质能让他变成混合运算？</p><p>首先我们说一下代数系统的定义：</p><ul><li>有一个非空的集合G和一个运算f</li><li>对于G中元素经过运算f之后所得的结果依然在G内</li></ul><p>我们就说G和f构成了代数系统，一般写作<code>&lt;G,f&gt;</code>。</p><p>所以这道题我们可以用代数系统的定义变化一下：</p><p>用波兰符号表示法就是最常见的7+11+11+11=40</p><h2 id="代数系统的元素"><a href="#代数系统的元素" class="headerlink" title="代数系统的元素"></a>代数系统的元素</h2><p>我们推广研究一下，既然这是一个代数系统，那么它一定会有一些性质：</p><ul><li>单位元：存在一个元素e，使得在与a经过运算后结果为a</li><li>零元：存在唯一元素0，使得与a经过运算后结果为0</li><li>逆元：对于元素a，存在一个元素$a^{-1}$使两者运算后得到单位元</li><li>幺元：算式列出之后每一个元素都是幺元，在算符左侧的叫左幺元，同理有右幺元</li></ul><p>对于初等代数系统我们简单的分析一下吧！</p><h2 id="简单代数系统"><a href="#简单代数系统" class="headerlink" title="简单代数系统"></a>简单代数系统</h2><p>(1)<script type="math/tex">，(2)</script>，(3)<script type="math/tex">，(4)</script></p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">单位元</th><th style="text-align:center">零元</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table></div><h2 id="运算法则"><a href="#运算法则" class="headerlink" title="运算法则"></a>运算法则</h2><p>假设x，y，z是集合S的元素。定义在S上的封闭运算<code>*</code></p><ul><li><p>交换律</p></li><li><p>结合律</p></li><li><p>分配律</p></li><li><p>消去律</p></li></ul><p>当然也可以从集合的角度分析代数系统，比如某代数的子叫做子代数。</p><p>一些特殊的代数系统，比如群，它的定义是满足结合律并且有单位元和逆元，这样的代数系统就是群。离散数学的图论和拓扑学有些许相似，可以彼此联系。</p>]]></content>
    
    
    <categories>
      
      <category>学业，技术，娱乐，新事物，笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>See how the COW finish the copy</title>
    <link href="/2022/06/22/The%20COW%20finish%20the%20copy/"/>
    <url>/2022/06/22/The%20COW%20finish%20the%20copy/</url>
    
    <content type="html"><![CDATA[<h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p>The COW is Copy on Write，In my reading the Redis Database’s code process，i have had a problem：How redis to finish write in file when have other thread using the file?</p><h2 id="Learning"><a href="#Learning" class="headerlink" title="Learning"></a>Learning</h2><p>Linux have some C function which named<code>fork()</code> and <code>exec()</code>,for example，i will write some code to show how these function work.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> time = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">pid_t</span> pid = fork();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,time);<br>&#125;<br></code></pre></td></tr></table></figure><p>now we use <code>gcc</code> to build the out file and run it.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs she">root@minloha:~&#x2F;LearnCcode&#x2F;fork# ls<br>main.c<br>root@minloha:~&#x2F;LearnCcode&#x2F;fork# gcc -g -o testmodel main.c<br>root@minloha:~&#x2F;LearnCcode&#x2F;fork# ls<br>main.c  testmodel<br>root@minloha:~&#x2F;LearnCcode&#x2F;fork# .&#x2F;testmodel<br>11<br>root@minloha:~&#x2F;LearnCcode&#x2F;fork# <br></code></pre></td></tr></table></figure><p>we can see the  shell have double 1，we use gdb testing it.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@minloha:~/LearnCcode/fork# gdb testmodel<br>(gdb) start<br>Temporary breakpoint 1 at 0x1169: file main.c, line 4.<br>Starting program: /root/LearnCcode/fork/testmodel<br><br>Temporary breakpoint 1, main () at main.c:4<br>4       void main(void)&#123;<br>(gdb) n<br>5           int time = 1;<br>(gdb) n<br>6           pid_t pid = fork();<br>(gdb) n<br>[Detaching after fork from child process 291435]<br>7           printf(&quot;%d&quot;,time);<br>(gdb) 1n<br>8       &#125;<br>(gdb) n<br>__libc_start_main (main=0x555555555169 &lt;main&gt;, argc=1, argv=0x7fffffffe568, init=&lt;optimized out&gt;,<br>    fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffe558) at ../csu/libc-start.c:342<br>342     ../csu/libc-start.c: No such file or directory.<br>(gdb)<br></code></pre></td></tr></table></figure><p>in line six , GDB tell us the child process have been detach,we copied the parent process to the child process. After the content is output, the child process automatically disengages,untill finish the testing and remove the main process from the stack.</p><p>In this process, although our program have runing,the new process also be created, this is COW(copy on write),the child process(renamed B) copy the parent process(renamed A)，if the system at this time still contains space, allocate a part to B so that B has enough resources to create child processes. if the space is insufficient, continue to use the resources of the parent process.</p><p>Is Redis，we need to make data persistent,But we couldn’t close the server, so we should use snapshotting , which is copy on write</p><h2 id="Expend"><a href="#Expend" class="headerlink" title="Expend"></a>Expend</h2><p>except Copy on write，also have read on write（ROW）there are many similarities between the two. COW and ROW all used into snapshot technology</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创意化的Webassembly</title>
    <link href="/2022/05/24/%E5%88%9B%E6%84%8F%E5%8C%96%E7%9A%84Webassembly/"/>
    <url>/2022/05/24/%E5%88%9B%E6%84%8F%E5%8C%96%E7%9A%84Webassembly/</url>
    
    <content type="html"><![CDATA[<h1 id="Webassembly"><a href="#Webassembly" class="headerlink" title="Webassembly"></a>Webassembly</h1><p>Webassembly是一种兼容Web的容器，它并不是一门新的编程语言，它更像一种新的编译器，可以帮助代码解释到二进制方向。同时它是一套完整的语义系统，你也可以像使用Docker一样使用Webassembly。从命名的角度Webassembly可以写作单词的组合，也就是：Web base simply（简单网络基础）读音一定也是这样的（确信）</p><h2 id="完成开发"><a href="#完成开发" class="headerlink" title="完成开发"></a>完成开发</h2><p>我将会使用CMake完成这次开发，首先如果你不会CMake你可以看我之前的博客，地址都在文末。操作系统使用Ubuntu。</p><p>首先我们需要安装Emscripten：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bas"># 获取emsdk<br>git clone https:&#x2F;&#x2F;github.com&#x2F;juj&#x2F;emsdk.git<br><br>cd emsdk<br><br># 补齐文件库,如果速度过慢就需要代理咯,两串指令等价,用哪个都可以<br>.&#x2F;emsdk install latest<br>.&#x2F;emsdk activate latest<br><br># 添加指令<br>source .&#x2F;emsdk_env.sh<br># 注意官方汉语文档有误，请以博客所写为主<br></code></pre></td></tr></table></figure><p>然后再<code>emsdk</code>文件夹内创建一个文件夹，我们叫他<code>ahh</code></p><p>然后我们创建CMake项目文件夹，<code>CmakeLists.txt</code>的写法可以参考我的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@minloha:~/WebAssembly/demo01<span class="hljs-comment"># tree</span><br>.<br>├── build<br>├── CMakeLists.txt<br>└── src<br>    ├── CMakeLists.txt<br>    └── main.cpp<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 这是项目根目录</span><br><span class="hljs-keyword">PROJECT</span> (MinuiW)<br><span class="hljs-keyword">ADD_SUBDIRECTORY</span>(src)<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 这是src目录</span><br><span class="hljs-keyword">PROJECT</span> (MinuiW)<br><span class="hljs-keyword">SET</span>(SRC_LIST main.cpp)<br><span class="hljs-keyword">MESSAGE</span>(STATUS <span class="hljs-string">&quot;Building project!&quot;</span>)<br><span class="hljs-keyword">ADD_EXECUTABLE</span>(MinuiW <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure><p>我们在项目<code>main.cpp</code>写入我们的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/* 一段十分恶趣味的代码</span><br><span class="hljs-comment"> * @author Minloha</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;emscripten.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Exam</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Exam</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;分数是:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;score &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">Exam</span>(<span class="hljs-keyword">int</span> score) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;score = score;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> score;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Exam* e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Exam</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">delete</span> e;<br>    cout &lt;&lt; <span class="hljs-string">&quot;哈哈哈&quot;</span> &lt;&lt; endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>写完之后我们切换到<code>build</code>文件夹，完成代码编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> build/<br><br><span class="hljs-comment"># 使用emcmake进行make编译</span><br>emcmake cmake ..<br><br><span class="hljs-comment"># 生成最后的js文件</span><br>emmake make<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@minloha:~/WebAssembly/demo01<span class="hljs-comment"># cd build/</span><br>root@minloha:~/WebAssembly/demo01/build<span class="hljs-comment"># emcmake cmake ..</span><br>configure: cmake .. -DCMAKE_TOOLCHAIN_FILE=/root/emsdk/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake -DCMAKE_CROSSCOMPILING_EMULATOR=/root/emsdk/node/14.18.2_64bit/bin/node;--experimental-wasm-threads<br>-- Building project!<br>CMake Warning (dev) <span class="hljs-keyword">in</span> CMakeLists.txt:<br>  No cmake_minimum_required <span class="hljs-built_in">command</span> is present.  A line of code such as<br><br>    cmake_minimum_required(VERSION 3.16)<br><br>  should be added at the top of the file.  The version specified may be lower<br>  <span class="hljs-keyword">if</span> you wish to support older CMake versions <span class="hljs-keyword">for</span> this project.  For more<br>  information run <span class="hljs-string">&quot;cmake --help-policy CMP0000&quot;</span>.<br>This warning is <span class="hljs-keyword">for</span> project developers.  Use -Wno-dev to suppress it.<br><br>-- Configuring <span class="hljs-keyword">done</span><br>-- Generating <span class="hljs-keyword">done</span><br>-- Build files have been written to: /root/WebAssembly/demo01/build<br>root@minloha:~/WebAssembly/demo01/build<span class="hljs-comment"># ls</span><br>CMakeCache.txt  CMakeFiles  cmake_install.cmake  Makefile  src<br>root@minloha:~/WebAssembly/demo01/build<span class="hljs-comment"># emmake make</span><br>make: make<br>Scanning dependencies of target MinuiW<br>[ 50%] Building CXX object src/CMakeFiles/MinuiW.dir/main.o<br>[100%] Linking CXX executable MinuiW.js<br>[100%] Built target MinuiW<br>root@minloha:~/WebAssembly/demo01/build<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>我们可以看到已经生成了<code>MinuiW.js</code>文件，我们浅浅的看一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@minloha:~/WebAssembly/demo01/build<span class="hljs-comment"># cd src</span><br>root@minloha:~/WebAssembly/demo01/build/src<span class="hljs-comment"># ls</span><br>CMakeFiles  cmake_install.cmake  Makefile  MinuiW.js  MinuiW.wasm<br></code></pre></td></tr></table></figure><p>我们看到了出现wasm文件和基础js文件，我们把两个文件同时取出，把Js引入我们的html文件中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>WebAssembly<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;MinuiW.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们简单运行一下，按F12打开控制台可以看到输出了内容</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/webass/img1.png" alt="img1" style="zoom:150%;" /></p><p>当然这是一种完全不同于CGI渲染的体系，它把C++代码用自己的方式渲染为了JS文件，我们浅浅的看一下生成的文件</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/webass/img2.png" alt="img2"></p><p>足足有5k行，可见一斑。</p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>这种技术也有缺点，那就是没办法完成DOM，仅仅是BOM，这也意味着无法真正做到一个Html蜕变成媲美服务器的性能，当然也需要依赖最基础的HTTPS服务器，那么就先期待着吧！</p><h2 id="网址大全"><a href="#网址大全" class="headerlink" title="网址大全"></a>网址大全</h2><p>官网：<a href="https://www.wasm.com.cn/">https://www.wasm.com.cn/</a></p><p>Cmake使用：<a href="https://blog.minloha.cn/2022/01/26/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8BCMAKE%E7%9A%84%E7%AC%94%E8%AE%B0/">https://blog.minloha.cn/2022/01/26/记录一下CMAKE的笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>新事物</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>完整的命题论</title>
    <link href="/2022/05/21/%E5%91%BD%E9%A2%98%E5%9C%A8%E7%A6%BB%E6%95%A3%E4%B8%AD/"/>
    <url>/2022/05/21/%E5%91%BD%E9%A2%98%E5%9C%A8%E7%A6%BB%E6%95%A3%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="命题论"><a href="#命题论" class="headerlink" title="命题论"></a>命题论</h1><p>人类的语言是高级的，人脑的抽象功能为我们抽象出了各种思维模式，当然也包含推理判断能力，而命题就是将这种判断的逻辑取出研究的工具，让我们好好看看什么是命题吧！</p><h2 id="命题和联结词"><a href="#命题和联结词" class="headerlink" title="命题和联结词"></a>命题和联结词</h2><p>命题的定义：具有确切真假值的陈述句叫做命题。命题可以取值，叫做真值，也就是真假一般写作1(T)和0(F)</p><p>命题的联结词：只有五种，有一部分在高中的命题中叫他们<code>与</code>、<code>或</code>、<code>非</code>，符号分别是<code>∧</code>、<code>∨</code>、$\neg$，而在离散数学中按顺序它们分别被叫做<code>合取联结词</code>、<code>析取联结词</code>、<code>否定联结词</code>。同时命题还有蕴含联结词，他的符号是<code>→</code>，写法是$P→Q$，其中P叫做蕴含的前件，Q叫做蕴含的后件，读法是P蕴含于Q，真值情况是只有当P的解集是Q解集的子集时，蕴含真值为1。那么既然有蕴含就有等价，等价联结词是<code>⇿</code>，记作$P↔Q$，读作P等价于Q，只有当P和Q解集相等时，真值为1。</p><h3 id="列举"><a href="#列举" class="headerlink" title="列举"></a>列举</h3><p>以下是所有联结词：</p><div class="table-container"><table><thead><tr><th>联结词</th><th>符号</th><th>含义</th><th>读法</th><th>写法</th><th>逻辑含义</th></tr></thead><tbody><tr><td>否定</td><td>$\neg$</td><td>真值结果否定</td><td>非P</td><td>$\neg P$</td><td>真假互换</td></tr><tr><td>合取</td><td>∧</td><td>真值取和运算</td><td>P合取Q</td><td>P∧Q</td><td>同真异假</td></tr><tr><td>析取</td><td>∨</td><td>真值取或运算</td><td>P析取Q</td><td>P∨Q</td><td>一真为真</td></tr><tr><td>蕴含</td><td>→</td><td>真值的包含运算</td><td>P蕴含Q</td><td>P→Q</td><td>大数含小数</td></tr><tr><td>等价</td><td>⇿</td><td>真值结果相等运算</td><td>P等价Q</td><td>P⇿Q</td><td>完全相等</td></tr></tbody></table></div><p>以下是真值表：</p><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>$\neg$P</th><th>P∧Q</th><th>P∨Q</th><th>P→Q</th><th>P⇿Q</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><hr><p>命题分为几种，其中最常用的就是原子命题，<strong>原子命题</strong>是一类命题的总称，它是不可再分的极简命题，有明确的真值。而将原子命题通过联结词组合起来就有了<strong>复合命题</strong>。</p><blockquote><p>例子</p></blockquote><p>P：我是好人</p><p>Q：我是Minloha</p><p>那么P∧Q=我是好人并且我是Minloha，P∨Q=我是好人或者我是Minloha，$\neg P$=我不是好人。</p><h3 id="符号化"><a href="#符号化" class="headerlink" title="符号化"></a>符号化</h3><p>下面是如何将命题符号化，举几个例子就可以了！</p><blockquote><p> 如果明天女朋友过生日，我就不能陪你出去买书</p></blockquote><p>P：明天女朋友过生日</p><p>Q：我陪你去买书</p><p>那么符号化就是$P→\neg Q$</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>命题可以解决一些逻辑门的问题，比如下面的电路图：</p><p><img src="https://pics6.baidu.com/feed/dc54564e9258d10937cf0c969b8a8bb76d814dc4.jpeg?token=811f0708d705d9b16381c59b627c12f9" alt=""></p><p>对于灯泡L，它可以选择在A开关闭合时亮起，也可以是B开关闭合时亮起，也可以是AB同时闭合，那么他的表达就是：$A∧B$</p><h2 id="命题公式"><a href="#命题公式" class="headerlink" title="命题公式"></a>命题公式</h2><p>命题公式是一个难点。我们先前定义过原子命题的含义，如果一个命题在没有赋予具体内容的前提下真假性不确定，我们叫这种命题为<strong>命题变量</strong>，反之被赋予内容的命题叫做<strong>常值命题</strong>，当一个原子命题是命题变量时，我们也叫他<strong>原子命题变元</strong>，将不同的命题变元、原子命题变元组合起来时，组成的复合命题也被叫做命题函数，或者按照离散数学所述，叫做<code>命题公式</code>或者真值函数。</p><p>命题公式的表达必须满足复合命题，比如$P→Q$就可以表示一个命题公式，但是$P∧Q→$就不是一个命题公式，因为蕴含联结词没有后件。</p><p>命题公式的表达也被叫做合式公式(WFF)，下面给出几点推论：</p><ul><li>命题变元本身就是一个命题公式</li><li>如果命题P是公式，其否定也是公式</li><li>如果多个命题都是公式，则它们通过联结词连接的复合命题也是公式</li><li>通过有限步骤使用上述推论的才是命题公式</li></ul><p>那么命题公式的使用可以使用真值表技术</p><p>在介绍真值表前我们需要了解，通过给命题变元赋值得到真值这个过程中，对命题变元的一组值叫做命题的一个<code>解释</code>，下面给出一个命题公式：</p><script type="math/tex; mode=display">(P∧Q)→(\neg P ∨Q)</script><p>那么对于公式真值可以画出下表，其中蕴含一列表示最后的真值：</p><div class="table-container"><table><thead><tr><th>P</th><th>Q</th><th>P∧Q</th><th>→</th><th>$\neg P$</th><th>$\neg P$∨Q</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td></tr></tbody></table></div><p>看了上面的真值表，不免让人联想，如果命题变元无论取何真值，命题公式的真值都为1，那这种命题公式叫什么呢？</p><h2 id="命题公式分类"><a href="#命题公式分类" class="headerlink" title="命题公式分类"></a>命题公式分类</h2><p>对于无论给定何种解释，命题公式的真值始终为1的叫做永真公式，反之叫做永假公式，而对于并不是所有解释都可以为真的命题公式，它是<strong>可满足的</strong>，解释一般用字母<code>I</code>表示。</p><p>简单的过度例子来一个，请判断下面的命题是否为永真公式：</p><script type="math/tex; mode=display">(P→Q)↔\neg P∨Q</script><p>列出真值表，可以看出这个命题公式是永真的，下一部分我们会细致讲解这个公式：</p><div class="table-container"><table><thead><tr><th>P</th><th>→</th><th>Q</th><th>↔(最终真值)</th><th>$\neg P$∨Q</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><h2 id="命题的演算公式"><a href="#命题的演算公式" class="headerlink" title="命题的演算公式"></a>命题的演算公式</h2><p>因为这里的公式比较多，我也写不过来，有兴趣可以在评论区补充，我挑几个常用的列举以下</p><ul><li>分配律<ul><li>P∧(Q∨R)=(P∧Q)∨(P∧R)</li><li>P∨(Q∧R)=(P∨Q)∧(P∨R)</li></ul></li><li>德摩根律<ul><li>$\neg (P∨Q)=\neg P∧\neg Q$</li><li>$\neg (P∧Q)=\neg P∨\neg Q$</li></ul></li><li>蕴含律<ul><li>(P→Q)=$\neg P∨Q$</li></ul></li><li>吸收律<ul><li>P∧(P∨Q)=P</li><li>P∨(P∧Q)=P</li></ul></li><li>常值运算<ul><li>G∧1=G</li><li>G∨0=G</li><li>$\neg G∧G=0$</li><li>$\neg G∨G=0$</li></ul></li></ul><p>你可以选择使用真值表证明，也可以像集合一样使用Venn图表示。</p><p>下面介绍两个需要当作常识的定理。</p><ul><li>设G是一个含有n个命题变元P的公式，假设它是永真或永假公式，那么它的演算结果也是永真或永假的</li><li>设$G_1$是G的一个子公式，H为任意一个公式，它的一个子公式为$H_1$，如果$G_1=H_1$那么G=H</li></ul><p>那么运用上面所讲内容完成下面命题公式的化简吧！</p><script type="math/tex; mode=display">(\neg P∧(\neg Q∧R))∨((Q∧R)∨(P∧R))</script><h2 id="联结词的完备集"><a href="#联结词的完备集" class="headerlink" title="联结词的完备集"></a>联结词的完备集</h2><p>这里主要讲完备集的定义，对于联结词主要涉及基本的联结词，而完备集只是一个集合的特殊名称，它是一个由联结词组成的集合，它依然拥有集合的性质，比如互异性，确定性什么的，可以看第一章</p><h3 id="符号扩充"><a href="#符号扩充" class="headerlink" title="符号扩充"></a>符号扩充</h3><p>除了之前说过的<code>合取联结词</code>、<code>析取联结词</code>、<code>否定联结词</code>、<code>蕴含联结词</code>、<code>等价联结词</code>之外，通过对电路分析得到了更多的计算符号，因为Markdown支持的符号有限，我就直接给个传送门，自己看看就好，我就不写了</p><p>传送门：<a href="https://blog.csdn.net/myRealization/article/details/120175992">https://blog.csdn.net/myRealization/article/details/120175992</a></p><h3 id="联结词的完备集-1"><a href="#联结词的完备集-1" class="headerlink" title="联结词的完备集"></a>联结词的完备集</h3><p>如果一个命题公式，都有由一个联结词集合S表示出来的命题公式和它是等价的，那么S是完备的联结词集合。如果S刚好满足完备集的定义并且元素足够少，那么就说它是一个极小完备的联结词集合，比如最经典的蕴含式：</p><script type="math/tex; mode=display">P→Q=\lnot P∨Q</script><p>可以看到左侧的命题公式可以由<code>&#123;→&#125;</code>的集合表示，而它的等价公式，由两种联结词组成，那么这两个联结词组成了一个极小完备的联结词集合，{$\lnot$，∨}，这种表示方法也被称作布尔代数系统</p><p>这里的知识点用于题目中给定，让你推到命题公式到仅由完备联结词集合表示。</p><h2 id="项与范式"><a href="#项与范式" class="headerlink" title="项与范式"></a>项与范式</h2><p>范式是一种公式的表达形式，准确的说它是一种约定俗成的表达格式，它可以完成很多事情，也在接下来的命题推理与证明中使用。</p><p>为了接下来的讲述，我们先下几个定义：</p><ul><li>命题变元或者其否定我们叫他<em>文字</em></li><li>有限个文字的析取叫做析取式，也被叫做<strong>子句</strong></li><li>有限个文字的合取叫做合取式，也叫做<strong>短语</strong></li><li>命题P和它的否定称为<strong>互补对</strong></li></ul><p>而范式的定义如下：</p><ul><li>有限个短语的析取式叫做<strong>析取范式</strong></li><li>有限个子句的合取式叫做<strong>合取范式</strong></li></ul><p>简单做一个题试试，求出公式的合取范式与析取范式：</p><script type="math/tex; mode=display">(P→\lnot H)∨(P↔R)</script><p>答案是这样的：</p><script type="math/tex; mode=display">合取范式:(\lnot P∨\lnot Q∨\lnot P∨R)∧(\lnot P∨\lnot Q∨\lnot R∨P)</script><script type="math/tex; mode=display">析取范式:\lnot P∨\lnot Q∨R</script><p>在理解了范式之后就是关于主合取范式和主析取范式的解释，在开始时，我们先介绍一下极小项和极大项。</p><p>在一个含有n个命题变元P的短语或者子句中，如果每个命题变元与其否定不同时存在，并且两者中的一个出现仅出现一次，那么就说这个短语或者子句是关于含有n个命题变元P短语或子句的极小项或者极大项。</p><p>这个定义是修饰后的，为了理解我简单举一个例子，假设命题变元P和Q：</p><script type="math/tex; mode=display">极小项:P∧Q,P∧\lnot Q,\lnot P∧Q,\lnot P∧\lnot Q</script><script type="math/tex; mode=display">极大项:P∨Q,P∨\lnot Q,\lnot P∨Q,\lnot P∨\lnot Q</script><p>而如果在给定的析取范式中，如果每一个短语都是极小项，那么这个范式叫做主析取范式。同理，一个合取范式，如果每一个短语都是极大项，那么这个范式就叫主合取范式。</p><h2 id="演绎推理与证明"><a href="#演绎推理与证明" class="headerlink" title="演绎推理与证明"></a>演绎推理与证明</h2><p>演绎并不一定推出真结果，只要过程是真的就是有效的推理，对于所有给出的前提，如果前提Q和结论H能够满足下面的条件，才能说明这是永真公式。</p><script type="math/tex; mode=display">\vee _{i=1}Q_i→H</script><p>推理符与蕴含符不同，写作<code>⇨</code>，常用的推理公式我列举一下：</p><ul><li>选言三段论：$\lnot G,G∨H\Rightarrow H$$\lnot G,G\bar ∨H⇨ H$</li><li>肯定前件式：$G,G→H⇨ H$</li><li>否定后件式：$\lnot H,G→H⇨ \lnot G$</li><li>假言三段论：$G→H,H→I⇨G→I$</li></ul><p>推理满足三个规则：</p><ul><li>(P)前提引用规则：在推理过程中，任何位置都可以引入前提</li><li>(T)结果引用规则：推理结果可以引用多前提推出的结果</li><li>(CP)如果前提集合和公式P能推导出S，那么集合就可以推出P→S</li></ul><p>推理也可以用真值表，给出合理的解释判断结果是否恒真，是则一致</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息熵与赫夫曼算法</title>
    <link href="/2022/05/12/%E4%BF%A1%E6%81%AF%E7%86%B5%E4%B8%8E%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%AE%97%E6%B3%95/"/>
    <url>/2022/05/12/%E4%BF%A1%E6%81%AF%E7%86%B5%E4%B8%8E%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>信息论</p></blockquote><p>信息熵是信息论第一个研究的对象，在通信理论中，对于解决临界数据压缩的值和临界通信传输速率的值，对应就是信息熵和信道容量，而信道容量通常是由输入信号与输出信号的最大互信息决定。</p><p>赫夫曼算法不同于其他的编码，比如<code>Shannon-Fano-Elias</code>编码，它是一种基于<code>最优树</code>的码字算法，对于有限字符长度的信息，赫夫曼算法得到的编码具有更多的期望长度，不过两者平均编码长度一直在<code>(H,H+1)</code>内。</p><p>对于信息熵有计算公式：</p><script type="math/tex; mode=display">H(x)=-\sum_{x∈χ}^∞p(x)log_2\, p(x)</script><p>对于条件事件的信息熵，我们还可以通过两个随机变量写出联合熵，它的形式如下：</p><script type="math/tex; mode=display">H(X,Y)=-\sum_{x∈χ}\sum_{y∈Υ}p(x,y)\:log\,p(x,y)</script><p>简单的计算化简，还可以得到链式法则：</p><script type="math/tex; mode=display">H(X,Y)=H(X)+H(X|Y)</script><blockquote><p>χ是第二十二个希腊字母，读音类似英语单词He，读作/chi/</p></blockquote><p>当然信息熵适用于基本事件概率不均等的信息熵求解，对数下是以2为底，所以H(x)的单位是bit，如果是<code>ln p(x)</code>得出的单位就是<code>nat</code>。显而易见的是，H(x)恒大于等于0，也就是熵的非负性。从概率p(x)我们可以推断出，x是一个泛函数，依赖于分布函数。</p><p>其他类型的编码比如信源编码和费诺编码本质原理相同，出于对图论的学习，我就不说了。</p><blockquote><p>图论</p></blockquote><p>对于树，我们可以区分为使用有向边连接的有向树和无向边连接的无树，对于一个有限的码字，假设它的长度为你，它可以自前向后分割为n个不同长度的子串，这些叫码字的前缀，而如果存在一个集合，它是一个有限长度码字前缀的集合，前缀之间不互相为前缀，那么叫集合内元素为前缀码，如果前缀码只使用了<code>0</code>和<code>1</code>表示，就说它是二元前缀码。</p><p>假设一个含权二元树，它保证每一条叶和枝所有权重最小，也就是满足下面表达式，其中L(w)表示结点所在层，求出的w(T)就是树权。</p><script type="math/tex; mode=display">w(T)=\sum_{i=1}^tw_iL(w_i)</script><p>赫夫曼算法主要完成下面四个步骤：</p><ul><li>1、将所有的结点含权放入集合C中</li><li>2、取出两个C中最小的元素，作为儿子，连接为父亲，父亲的权重为左儿子和右儿子的和</li><li>3、在C中去除两个儿子结点，加入父亲结点</li><li>4、判断C是否为空，不为空返回第二步</li></ul><p>通过赫夫曼算法的到的根数就是最优树。从根开始依次给边赋权，左子树为1，右子树为0，那么就可以得出最优前缀码。</p><h2 id="举例子"><a href="#举例子" class="headerlink" title="举例子"></a>举例子</h2><blockquote><p>Minloha打算使用单片机通过传递电磁波完成选择题答案的传输，请你帮他设计一份编码，使数据传输最简洁。据统计，选择题出现A的概率为22%，出现B的概率为13%，出现C的概率为37%，出现D为28%</p></blockquote><p>这题是单变量，那我们就用信息熵算出最大压缩量</p><script type="math/tex; mode=display">H(x)=-\sum p(x)log\;p(x)</script><script type="math/tex; mode=display">H(x)=-(0.22·log\;0.22+0.13·log\;0.13+0.37·log\;0.37+0.28·log0.28)</script><p>我们简单的计算一下，得到<code>H(x)=1.90816694686</code>取整为2，也就意味着我们只用2个码字就可以表示它们了，那我们画出它的二元树：</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/huffman/1.png" alt="二元树"></p><p>可以非常简单的看出，A表示为001，B表示为000，C表示为1，D表示为01，那么我们算一下平均码字长度，大小为2.25，比较接近我们的信息熵大小。</p><p>对比的，我们也算一下香农码，香农码计算公式为：</p><script type="math/tex; mode=display">l(x)=\lceil log\;\frac{1}{p(x)} \rceil</script><p>分别计算一下，可以算出A的码字长度为<code>2.18442457114</code>取整为3，B的码字长度为<code>2.94341647163</code>取整为3，C香农码字长为<code>1.43440282415</code>取整为2，D长<code>1.83650126772</code>取整为2，列表看看赫夫曼码字长度和香农码字长度大小比较</p><div class="table-container"><table><thead><tr><th>字符</th><th>理想码字长度</th><th>取整后码字长度</th><th>赫夫曼码字长度</th></tr></thead><tbody><tr><td>A</td><td>2.18442457114</td><td>3</td><td>3</td></tr><tr><td>B</td><td>2.94341647163</td><td>3</td><td>3</td></tr><tr><td>C</td><td>1.43440282415</td><td>2</td><td>1</td></tr><tr><td>D</td><td>1.83650126772</td><td>2</td><td>2</td></tr></tbody></table></div><p>可以看出赫夫曼编码还是十分契合理想码字长度的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇主要介绍了信息熵与赫夫曼编码的概念，通过阅读可以让读者明白计算的笔算方法，也可以通过不同的编程语言实现相应的功能。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信技术</tag>
      
      <tag>算法</tag>
      
      <tag>信息论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>补番推荐：堀与宫村</title>
    <link href="/2022/04/28/%E8%A1%A5%E7%95%AA%E6%8E%A8%E8%8D%90%EF%BC%9A%E5%A0%80%E4%B8%8E%E5%AE%AB%E6%9D%91/"/>
    <url>/2022/04/28/%E8%A1%A5%E7%95%AA%E6%8E%A8%E8%8D%90%EF%BC%9A%E5%A0%80%E4%B8%8E%E5%AE%AB%E6%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p>其实说来也惭愧，其实这部番在它还是漫画的时候我就已经看过了，只是当时并没有现在这么新鲜的经历，因为当时我正是大低谷时期也就是两三天不说话就憋着的时候，当时可能更多的是以旁观者的视角看动漫角色丰富的生活，也借机感慨一下自己的不如意吧。不过现在虽然大同小异，但是收获的感觉更多了，所以我迫不及待的想要写一篇博客来分享一下这份新鲜的感受、</p><p>堀与宫村是漫画改编至动漫，漫画因为原版太….简笔了，所以B站上的是二创优化的，原作者早早就已经完结了，也就没有续作的，这个故事的主人公从名字就可以看出了，就是堀(女主)和宫村(男主)。</p><p>堀与宫村是描述男女主从校服到婚纱这么一个过程的动漫，至于我对这中主题的观点文末会说，整部动画没有出现为了秀恩爱而刻意营造某一事件或者某一氛围，更多的是切实的温馨以及充实的校园生活。原作的定位是少女漫画，所以也不会出现像其他带着恋爱的校园剧，给你发很多很多刀子，全剧都是很甜的。</p><p>来来来，让我们接入B站看一下第一集吧！</p><blockquote><p><a href="https://www.bilibili.com/bangumi/play/ss36198">https://www.bilibili.com/bangumi/play/ss36198</a></p></blockquote><h1 id="故事概述"><a href="#故事概述" class="headerlink" title="故事概述"></a>故事概述</h1><blockquote><p>涉及剧透，谨慎观看</p></blockquote><p>每个人都有不为人知的一面，这是B站对它的介绍，其实确实如此，从全局上看，堀与宫村一开始都仅仅是彼此秘密的知情人，到后来才逐步发展为恋人（当然，安全上垒）。故事的线索是两人的恋爱经历，支线是两人朋友们的恋爱经历，通过观众带入为角色，一步一步感受到浓郁的狗粮气息(也可以带入为主角，享受一段甜甜的恋爱)。</p><p>故事在第一集基本将前提故事都已经叙述完全，从2集开始两人就可以确定是相互喜欢了，作为看过漫画的人，我很负责的说，其实这个速度按照少女漫画的角度，真的不快，因为观众不希望看到拖泥带水的历史，而是想看到堀和宫村甜甜的日常。</p><p>动漫在第5话时宫村向堀表白，两人也算是正式确定了恋人的关系（其实看到这里我当街大骂一句（来自单身狗的怒吼）），后来宫村为了减少流言蜚语剪短了头发，从抑郁青年变成了潮流先锋，同时两人的关系进一步达到火热。在动漫的第7话后半段，虽然动漫化后删去了部分，不过两人确实已经上垒也就是已经做了（原作中两人是有稍微详细的描述，不过毕竟是甜甜的恋爱嘛，这很正常）。在之后的故事中动漫算进入了支线，也就是以堀和宫村为旁观者见证朋友们的恋情。</p><hr><p>堀是真的护肤（夫）宝啊，每当宫村在重新会想起自己的历史时，都能正确引导甚至让我也觉得有一丝丝想要谈一个女朋友的欲望了（扯淡）。</p><h1 id="谈谈我的观点"><a href="#谈谈我的观点" class="headerlink" title="谈谈我的观点"></a>谈谈我的观点</h1><p>其实对于这种类型的作品，我也算略有涉及也有点研究，其实总结起来就一句话，从反问的语气说：知道为什么这种事情要放在影视作品中吗？因为它在现实世界是根本无法实现的。所以也就算是图一乐呵，如果你要是真的想要尝试一下在未成年期间找到一个可以陪你白头到老的那可就大错特错了，其实这也算是过来人的经历了，无论是心智也好，社会地位也好，就算再顺风顺水也都是在消耗彼此的感情，最后感情干涸了，也就没有这么多的感动了。</p><p>总之就是说，动漫是非常适合看的，因为它塑造形象很棒，但是如果你想尝试的话，从我的角度说就是：爱就是你在见到群星之后还忠于的那颗星。</p><p>最后因为对我来说，距离高考只剩下39天了，我剩余的时间不多了，所以与之想着要一个女朋友不如抓紧变成一个十分优秀的人，这样在我今后可以有更多的选择，毕竟我的总之就是：希望所有事情都是能够被我所预料的，而不是出其不意的嘛！</p><blockquote><p>关于更多我的三观可以前往<a href="https://www.minloha.cn">https://www.minloha.cn</a></p><p>或者是博客的“关于”板块，都可以了解Minloha哟~</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>番剧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>三观</tag>
      
      <tag>杂谈</tag>
      
      <tag>新鲜事</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于函数变换</title>
    <link href="/2022/04/25/%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E5%8F%98%E6%8D%A2/"/>
    <url>/2022/04/25/%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="复习变换"><a href="#复习变换" class="headerlink" title="复习变换"></a>复习变换</h2><p>高中我们对函数的伸缩拉伸有所研究，在高中一般称呼为伸缩变换，但当我们观察变化后的坐标系和原来的坐标系，经过对比可以明显发现，坐标系发生了变化，我们可以通过一个三角函数的例子演示一下：</p><script type="math/tex; mode=display">y=sinx</script><script type="math/tex; mode=display">y'=sin2x'</script><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/function/1.png" alt="1"></p><p>我们把变换后的函数换一种表示形式，即<code>y&#39;</code>与<code>y</code>,<code>x&#39;</code>与<code>x</code>的关系写出：</p><script type="math/tex; mode=display">\begin{cases}x'=2x\\y'=y\\\end{cases}</script><p>我们知道平面直角坐标系是Oxy，现在的坐标系是<code>Ox&#39;y&#39;</code>，从变化规则可以看出是对原Oxy坐标系的横轴<code>x</code>拉长2倍得到了新坐标系，而图像不变保持原来的位置，然后对齐新旧坐标系，就实现了图像的压缩。</p><p>同理我们也可以实现拉伸变换，还是使用正弦函数，我们做一下拉伸平移：</p><script type="math/tex; mode=display">y=sinx</script><script type="math/tex; mode=display">y'=2sin(2x'+\pi)+2</script><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/function/2.png" alt="2"></p><p>我们可以直观的看到，函数像弹簧一样被压缩，被拉伸，被平移，且我们可以写出变换规则：</p><script type="math/tex; mode=display">\begin{cases}x'=\frac{1}{2}{(x-\pi)}\\y'=2y+2\\\end{cases}</script><p>变化后的坐标系<code>Ox&#39;y&#39;</code>就是相对原<code>Oxy</code>坐标系的仿射</p><h2 id="下定义"><a href="#下定义" class="headerlink" title="下定义"></a>下定义</h2><p>对于函数f(x,y)它的图形完全在由任意一组向量的张成空间内，规定这组向量组成的仿射系为L并绘制f(x,y)，通过对L进行变换基操作，得到的L’坐标系同时放入f(x,y)在L系内的图形，则f(x,y)在L’坐标系的内解析式$f_T(x,y)$叫做f(x,y)的变换。</p><p>切记切记，是原图像在新坐标系放入后，把新坐标系与原坐标系对齐后得到的函数叫做函数的变换函数！</p><p>算符演算的标准定义：</p><blockquote><p>使问题从一种状态变化为另一种状态的手段称为操作符或算符。算符在单独存在时是没有什么意义。操作符可为走步、过程、规则、数学算子、运算符号或逻辑符号等。</p></blockquote><p>所以我们的函数变换也是一种算符演算，当然你也可以理解为是在基本向量空间内的泛函分析。具体内容可以看实变函数与泛函分析。</p><p>对于标准的变换，我们可以通过变换函数实现，对于变换函数规定为下面形式：</p><script type="math/tex; mode=display">A=[\vec v_1,\vec v_2]\\</script><script type="math/tex; mode=display">条件:det(A)≠0\\</script><script type="math/tex; mode=display">f_T(x,y)=f(A[x,y]^T)\\</script><p>函数$f_T(x,y)$就是f(x,y)的变换后函数。A是线性算符</p><p>对于函数的变换，它是针对坐标系本身而不是针对函数，也就意味着无论如何变换，原坐标系的关系都不会改变，这里可以归纳为二组性质：</p><ul><li>可逆性：存在f的反函数使得在L’内的图像可以重新回到原坐标系L内</li><li>相似性：原坐标系的关系，比如相切相交相离都不会改变</li></ul><p>而对于函数的变换，我们可以用两种办法求出，也就是极坐标法或矩阵法，我列举一下优缺点</p><div class="table-container"><table><thead><tr><th></th><th style="text-align:center">极坐标系</th><th style="text-align:center">矩阵</th></tr></thead><tbody><tr><td>优点</td><td style="text-align:center">是基础的内容便于理解，同时操作简单，前置基础要求不高，可以处理指定角度的旋转问题</td><td style="text-align:center">可以直接表达出变换关系，极坐标法有的优点它都有，可以完成坐标系的定向拉伸，计算简单，理论知识完备。</td></tr><tr><td>缺点</td><td style="text-align:center">无法处理伸缩问题，计算量大</td><td style="text-align:center">需要线性代数的知识</td></tr><tr><td>特点</td><td style="text-align:center">比较直观</td><td style="text-align:center">可以处理任意坐标系</td></tr></tbody></table></div><h2 id="仿射与矩阵变换"><a href="#仿射与矩阵变换" class="headerlink" title="仿射与矩阵变换"></a>仿射与矩阵变换</h2><p>我们都知道，对于任意两不共线向量的张成向量空间可以囊括整个二维平面的向量，而矩阵方程就是对这两个不共线向量（基）的操作，这里可以通过直观的例子感受一下，对于原坐标系，他的基向量是$\vec i$=(1,0)，纵$\vec j$=(0,1)，它们的列向量用矩阵表示就是：</p><script type="math/tex; mode=display">\left[\begin{matrix}1&0\\0&1\\\end{matrix} \right]</script><p> 这种矩阵不是很熟悉吗？这个叫单位矩阵，任何向量或矩阵与它做外积都是本身，也就是坐标系并没有改变，而我们将他改为以(1,1)(1,-1)为基的向量空间时，我们就需要对原坐标系的向量做矩阵变换，即<code>Ax=b</code>,其中：</p><script type="math/tex; mode=display">A=\left[\begin{matrix}1&1\\1&-1\\\end{matrix} \right]</script><p>x就是自变向量，一般写作：</p><script type="math/tex; mode=display">\left[\begin{matrix}x\\y\\\end{matrix} \right]或\left[\begin{matrix}x&y\\\end{matrix} \right]^T</script><p>b是变化后的向量，至于矩阵变化在之前说过，我给个传送门</p><blockquote><p><a href="https://blog.minloha.cn/2022/04/17/%E7%BB%86%E8%AF%B4%E7%9F%A9%E9%98%B5%E4%B8%8E%E5%8F%98%E6%8D%A2/">https://blog.minloha.cn/2022/04/17/%E7%BB%86%E8%AF%B4%E7%9F%A9%E9%98%B5%E4%B8%8E%E5%8F%98%E6%8D%A2/</a></p></blockquote><h2 id="函数变换"><a href="#函数变换" class="headerlink" title="函数变换"></a>函数变换</h2><p>函数变换这种知识其实并不存在，和矩阵方程一样，说出这个名词的（我）想表达函数变换其实是一个连续的过程。</p><p>首先我们先尝试一个二维空间内的二元函数：</p><script type="math/tex; mode=display">f(x,y)=\frac{x^2}{4}+y^2-1=0</script><p>绘制他的图像，我们得到了一个椭圆，然后我们思考一下，如何在坐标系Oxy顺时针旋转45°得到椭圆</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/function/3.png" alt="3"></p><p>答案是极坐标方程，我们知道极坐标极径、极角和直角坐标的关系 x=ρcosθ，y=ρsinθ，且x²+y²=ρ²，而我们只需要给极角θ加上45°即可获得旋转方程，那么我们代入化简一下就可以得到旋转后的函数了：</p><script type="math/tex; mode=display">\frac{5}{8}x^{2}+\frac{3}{4}xy+\frac{5}{8}y^{2}=1</script><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/function/4.png" alt="4"></p><p>为了清楚看到变化后的坐标系，我绘制了<code>Ox&#39;y&#39;</code>坐标系，可以看出变化后的<code>x&#39;</code>与原坐标系的<code>x</code>所成角度正好是45度。</p><p>那么我们总不能时刻都用极坐标系吧，不然这矩阵可就无处可施了，所以我们使用旋转矩阵R：</p><script type="math/tex; mode=display">R=\left[\begin{matrix}cos \theta&sin\theta\\-sin \theta&cos\theta\\\end{matrix} \right]</script><p>我们还是令θ=45°，椭圆上的点用列向量X=$[x，y]^T$（T为矩阵转置）表示，那么RX就是变化后的函数，我们通过矩阵外积计算一下结果可以轻松得到变化后的<code>x&#39;</code>和<code>y&#39;</code>关于原坐标x、y的方程，把<code>x&#39;</code>和<code>y&#39;</code>代会到解析式内，我们就可以计算出新函数了，它是这样的：</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/function/5.png" alt="5"></p><p>这里注意，矩阵是直接改变了坐标系，也就意味着是对坐标系本体发生了变换，如果想要完成换基，就需要用新基矩阵的逆去乘以变量向量。</p><p>相似的，我们可以再用两种办法研究一下双曲线，也就是在初中学习的反比例函数：</p><script type="math/tex; mode=display">y=\frac{1}{x}</script><p>我们对他进行化简，可以得到二元函数：</p><script type="math/tex; mode=display">f(x,y)=xy-1=0</script><p>第一种极坐标法，我们还是让角度为45°，我简单列一下计算过程。</p><script type="math/tex; mode=display">\rho cos\theta*\rho sin\theta=1</script><p>则可以计算θ’在参数方程的值，使用两角和打开正余弦，重新得到ρcosθ和ρsinθ</p><script type="math/tex; mode=display">\rho cos(\theta+\frac{\pi}{4})*\rho sin(\theta+\frac{\pi}{4})=1</script><script type="math/tex; mode=display">(\rho sin\theta-\rho cos\theta)(\rho sin\theta+\rho cos\theta)=2</script><p>即可推出：</p><script type="math/tex; mode=display">x^2-y^2=2</script><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/function/6.png" alt="6"></p><p>然后再来尝试一下矩阵，定义变换函数为g(x,y)，满足下面矩阵，不过注意，这是旋转矩阵的逆哦！</p><script type="math/tex; mode=display">T=\left[\begin{matrix}cos\frac{\pi}{4}&sin\frac{\pi}{4}\\sin\frac{\pi}{4}&-cos\frac{\pi}{4}\\\end{matrix} \right]</script><script type="math/tex; mode=display">f_T(x,y)=f(T·\left[\begin{matrix}x\\y\\\end{matrix} \right])</script><p>我们乘一下，得到下面的内容：</p><script type="math/tex; mode=display">x'=\frac{\sqrt 2}{2}(x+y)\\</script><script type="math/tex; mode=display">y'=\frac{\sqrt 2}{2}(x-y)\\</script><p>我们把<code>x&#39;</code>和<code>y&#39;</code>带入进f(x,y)中，得到新的方程：</p><script type="math/tex; mode=display">x^2-y^2=2</script><p>可以看到和我们使用极坐标是一样的。</p><h2 id="高级玩法"><a href="#高级玩法" class="headerlink" title="高级玩法"></a>高级玩法</h2><p>我们让坐标系变成斜二测画法的坐标系，操作对象就选择椭圆了：</p><script type="math/tex; mode=display">\frac{x^2}{4}+y^2=1</script><script type="math/tex; mode=display">T=\left[\begin{matrix}1&\frac{1}{2}\\0&\frac{1}{2}\\\end{matrix} \right]</script><p>那么就可以令f(x,y)是椭圆，求出它对应的变换函数了：</p><script type="math/tex; mode=display">f_T(x,y)=f(T·\left[\begin{matrix}x\\y\\\end{matrix} \right])</script><p>求解一下，得到变化后的方程已经图像如下：</p><script type="math/tex; mode=display">\frac{x^{2}}{4}+\frac{xy}{4}+\frac{5y^{2}}{16}=1</script><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/function/7.png" alt="7"></p><p>我们可以看出，矩阵变换可以完美解决伸缩坐标系的问题，至于y=x只是参考直线。</p><p>最后让我们看一个抛物线旋转的例子就结束吧！</p><script type="math/tex; mode=display">y^2=4x\\</script><script type="math/tex; mode=display">f(x,y)=\frac{y^2}{4x}-1=0(x≠0)\\</script><script type="math/tex; mode=display">T=\left[\begin{matrix}cos\frac{\pi}{4}&sin\frac{\pi}{4}\\sin\frac{\pi}{4}&-cos\frac{\pi}{4}\\\end{matrix} \right]</script><script type="math/tex; mode=display">f_T(x,y)=f(T·\left[\begin{matrix}x\\y\\\end{matrix} \right])</script><script type="math/tex; mode=display">f_T(x,y)=\frac{x^{2}}{2}-xy+\frac{y^{2}}{2}-2\sqrt{2}x-2\sqrt{2}y=0</script><p>绘制图像：</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/function/8.png" alt="8"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这种圆锥曲线的旋转是我在做刷数学题时在压轴选择题看到的，刚开始并不太在意。现在学完高数多元函数之后对旋转有一个全新的认知，所以就简单尝试了一下关于函数变换也就是旋转平移仿射等操作，所以有了这篇博文，如果有任何问题都可以在下面留言，我都会回复的呢！记得收藏本站地址</p><blockquote><p><a href="https://blog.minloha.cn">https://blog.minloha.cn</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>泛函分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>细说矩阵与变换</title>
    <link href="/2022/04/17/%E7%BB%86%E8%AF%B4%E7%9F%A9%E9%98%B5%E4%B8%8E%E5%8F%98%E6%8D%A2/"/>
    <url>/2022/04/17/%E7%BB%86%E8%AF%B4%E7%9F%A9%E9%98%B5%E4%B8%8E%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="基础概述"><a href="#基础概述" class="headerlink" title="基础概述"></a>基础概述</h2><p>为了让大家能更好理解这些内容，我会结合矩阵分析与泛函分析两个重量级选手说一说，大家一定要睁大眼睛哦！</p><p>需要知识：</p><ul><li>范数相关</li><li>矩阵相关</li><li>向量空间相关</li></ul><h2 id="向量与向量空间"><a href="#向量与向量空间" class="headerlink" title="向量与向量空间"></a>向量与向量空间</h2><p>向量（Vector）是一种有向线段，它是沟通代数和几何（注意是几何不是解析几何这种具体的）的桥梁，对于任意任意两个或两个以上的向量都可以按照线性关系组合成一定范围的其他向量，比如平面直角坐标系内常用的<code>i</code>和<code>j</code>向量，对于向量<strong>a</strong>(1,2)可以写作    <code>i+2j</code>的形式，表示线性组合。假设任意两个不共线的向量，它们可以组成平面内任意一个向量，所以我们就说两向量张成平面，同理，如果是两个共线向量，就说这两个向量可以张成直线。也可以推出三维空间内的任意三个不共线向量都可以张成三维空间。张成的向量就叫基向量或者简称为基（Base）。</p><p>向量的表示可以用有序数对表示，如<strong>a</strong>=（1，2）这种，也可以用矩阵的列向量表示，写作:</p><script type="math/tex; mode=display">\vec a=\left[\begin{matrix}1\\2\\\end{matrix} \right]</script><p>所以对于有限个向量从$n_1$直到$n_m$，对它们的张成向量空间（Vector Space）可以用下面的符号表示：</p><script type="math/tex; mode=display">Span \left\{ n_1,n_2,n_3,...,n_m \right\}</script><p>相似的这些向量可以按一定权重组成一个矩阵（Matrix）A，反之矩阵A也可以拆分为多个向量的线性组合：</p><script type="math/tex; mode=display">A=\left[\begin{matrix}\vec n_1,\vec n_2,\vec n_3,...,\vec n_m\end{matrix} \right]</script><p>我们所常用的平面系和空间系都是向量空间，可以通过轴线上的基向量张成，同时要是满足赋范向量空间则要满足三个性质：</p><ul><li>非负性<ul><li>$||\vec a ||≥0$</li></ul></li><li>齐次性<ul><li>$||a · \vec v|| = |a|·||\vec v||$</li></ul></li><li>三角不等式<ul><li>$||\vec v_1||+||\vec v_2|| ≥ ||\vec v_1 + \vec v_2||$</li></ul></li></ul><p>相似的对于向量空间的形状，我们可以将有限个基向量组合变成矩阵M，通过计算det(M)与0的大小关系判断向量张成是否为直线或者原点，这里要注意，n个向量最大可以张成的向量空间维度是n，我们就可以说把n组合成的矩阵的最大秩为n，且组合的矩阵秩不能大于n，应该小于或等于n，而这n个向量组合的矩阵也可以叫做线性向量组。注意！线性向量组中存在一个非零行或者叫行内存在主元，就给秩加一，如果存在一行的主元不存在，则不对秩加一操作。</p><h2 id="矩阵与向量结合"><a href="#矩阵与向量结合" class="headerlink" title="矩阵与向量结合"></a>矩阵与向量结合</h2><p>上一小部分我们浅谈了一句，就是说矩阵可以拆分为多组向量，对于这种运算，我们可以运用符号<code>vec()</code>表示，对于A来说，如果在<strong>x</strong>的变量向量内存在矩阵方程Ax=b，则我们就说这是一种矩阵变换（Matrix Translate），这种变换与映射十分类似，不过映射描述的是原像与像之间的对应关系（像序偶一样），而矩阵变换重在变换，它是一个过程，可以看作是原基向量空间内的任意向量通过矩阵A变换到vec(A)为基的新向量。</p><p>那么我们可以实现基本的矩阵变换了，我们随便取照片，利用python的numpy计算并演示一下！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pylab <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib.patches <span class="hljs-keyword">import</span> Ellipse<br><span class="hljs-comment"># 这是仿射规则,可以随便改改</span><br>rule = np.array([<br>    [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>])<br><span class="hljs-comment"># 规定椭圆的半长轴和半短轴</span><br>a,b=<span class="hljs-number">2</span>,<span class="hljs-number">1.141</span><br>res = np.array([[a,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,b]]).dot(rule)<br><br>fig = plt.figure(<span class="hljs-number">0</span>)<br>ax = fig.add_subplot(<span class="hljs-number">111</span>, aspect=<span class="hljs-string">&#x27;equal&#x27;</span>)<br><span class="hljs-comment"># 规定圆心为(0,0),绘制未经过仿射的椭圆</span><br>e = Ellipse(xy = (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), width = a, height = b)<br><span class="hljs-comment"># 规定圆心为(0,0)并使用仿射结果</span><br>e2 = Ellipse(xy = (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), width = res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], height = res[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<br><span class="hljs-comment"># 显示e(未经过仿射变换)或者e2(经过仿射变换)</span><br>ax.add_artist(e)<br><span class="hljs-comment">#ax.add_artist(e2)</span><br><br>e.set_facecolor(<span class="hljs-string">&quot;black&quot;</span>)<br>plt.xlim(-<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br>plt.ylim(-<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br>ax.grid(<span class="hljs-literal">True</span>)<br>plt.title(<span class="hljs-string">&quot;We had been translated&quot;</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure><p>为经过仿射变换的椭圆如图：</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/matrix/img1.png" alt="img1"></p><p>修改python代码中的rule矩阵，变为下面形式，表示y轴放大二倍，得到的就是下图：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">rule = np.<span class="hljs-built_in">array</span>([<br><span class="hljs-string">    [1,0]</span>,<br><span class="hljs-string">    [0,2]</span><br>])<br></code></pre></td></tr></table></figure><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/matrix/img2.png" alt="img2"></p><p>当然变换也有旋转变换和剪切变换，这里大家可以通过修改代码或者效果，我这里只说明理论：</p><p>比如对于坐标系Oxyz而言，存在一个正方体，他的边长为1，那么他的体积就是1，接下来简称它为单位体，对坐标系沿着某一个坐标轴进行旋转变换（比如z轴），我们可以使用下面的矩阵：</p><script type="math/tex; mode=display">T_z=\left[\begin{matrix}cosα&&sinα&&0\\-sinα&&cosα&&0\\0&&0&&1\\\end{matrix} \right]</script><p>相似的，我们也可以按照不同的方向对矩阵进行旋转变换。变换规则可以参考下面的链接</p><blockquote><p><a href="https://wenku.baidu.com/view/f5f2f106ac45b307e87101f69e3143323968f593.html">https://wenku.baidu.com/view/f5f2f106ac45b307e87101f69e3143323968f593.html</a></p></blockquote><p>我们都知道或者不知道，研究生需要学习各种数学模型的分析，比如泛函分析矩阵分析或者数学分析数学优化（如有列举错误可以在评论区指正，我会尽快修改）那么本次的博文就是出于增长基础见识为前提写的，所以研究生们加油！</p><h2 id="小小总结一下"><a href="#小小总结一下" class="headerlink" title="小小总结一下"></a>小小总结一下</h2><p>线性代数绝对不是我短短一篇文字能说的完的，这些需要不断学习理解与想象，而泛函分析这部分的知识，我还不是十分透彻，因为我只学过图论看过离散，却没有学过拓扑学，特别是使用拓扑代数，我完全不懂。所以小小博文到此结束，记得分享出去哦~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈图论</title>
    <link href="/2022/04/04/%E6%B5%85%E8%B0%88%E5%9B%BE%E8%AE%BA/"/>
    <url>/2022/04/04/%E6%B5%85%E8%B0%88%E5%9B%BE%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h1><p>在现在的计算机网络工程中，最不可或缺的就是拓扑图，其实拓扑图就是图的一个变种。对于拓扑学，它和图论的区别是应用场所不同，图是一个工具，而拓扑是切实通过代数运算的工具，拓扑应用的较多就是泛函分析，后面可能会说。图论在现代应用于线性代数或者密码学中，涉及表达的地方，都会有图存在。</p><p>图论是数学领域中发展最快的分支之一,数学史上著名的七桥问题欧拉只用了一步就证明了不重复地通过7座桥的路线是根本不存在的!这是拓扑学研究的先声。图的染色问题一直是图论研究的焦点问题。数学家赫伍德(Hedwood)成功地运用肯普的方法证明了五色定理,即一张地图能够用五种或者更少的颜色染色。美国伊利诺斯大学的黑肯(W.Haken)和阿佩尔(Appel),经过四年的艰苦工作.终于完成了四色猜想的证明。正是上述那些似乎没有多大意义的游戏的抽象与论证的方法,开创了图论科学的研究。</p><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p><img src="https://pic2.zhimg.com/80/v2-f4b892636ad226e23fe59b2512547a35_720w.jpg" alt="这就是图" style="zoom:150%;" /></p><h2 id="点和边"><a href="#点和边" class="headerlink" title="点和边"></a>点和边</h2><p>图论的要素就是点和边了，点没什么说的，用一个空心圆表示点。边有区别，在离散数学的二元关系的一章中，会知道二元关系就是图论中的一种叫<code>有向边</code>的边，在图上表现出序偶的第一元素用箭头指向第二元素。写出来一个从a到b的二元关系为<code>&lt;a,b&gt;</code>。如果描述的是集合之间的二元关系如A和B，那么就可以写为笛卡尔积<code>A×B</code>表示A与B之间的二元关系。相似的，对于A到B集合也可以从函数角度分析，A集合通过映射<code>f</code>到B集合，为了映射达到满射，引出了函数的置换，记作：</p><script type="math/tex; mode=display">f^{(n)}(x)</script><p>其中n叫做置换阶，常见的比如切比雪夫多项式，就是一种置换函数。有向边组成的有向图的一个性质是度(degree)，对于一个点它可以有出度和入度，表示为<code>deg(v)</code>，它可以衡量图的同构。相似复习一下二元关系在有向图的性质，也就是下面的三个性质。</p><ul><li>自反性(r)</li><li>对称性(s)</li><li>传递性(t)</li></ul><p>在初学二元关系就已经引入图了，所以有向图应该是接触较早的。在学习二元关系中有一个难点，就是等价关系和次序关系，等价关系是一个同时具备自反性，对称性和传递性的关系R，在他的元素集合A中，满足：</p><script type="math/tex; mode=display">R∈A^{(n)}</script><p>同时对于关系R，它的第一元素组成的集合是集合A的等价类。次序关系中比较难的就是偏序关系，拟序关系还好说，拟序集用符号<code>&lt;A,&lt;&gt;</code>表示，偏序集用符号<code>&lt;A,≤&gt;</code>表示。对于偏序关系R，他要有自反性，反对称性和传递性。这里会引出哈斯图的概念，不过无非就是省略自环和箭头的图，也就不细说了。同时对偏序关系的特殊元素还要记得，最大与极大、最小与极小，不一定同时存在。</p><hr><p>如果两元素不存在向性关系，也就是无序，那就可以用无序对表示，同样，对于元素a、b它的无序对表示为<code>(a,b)</code>。也可以用集合的笛卡尔积表示，不复写了。一般对于一个图(Graph)点一般放进集合V，边放进集合E，则对于一个图可以记作<code>G=&lt;V,E&gt;</code>，可以画图或者使用邻接矩阵表示，对与矩阵也就会有类似矩阵方程的计算，离散中独有的就是布尔乘积，它是通过类似矩阵乘法的叉乘，不过最终点是通过析取联结词运算的。</p><p><img src="https://pic4.zhimg.com/80/v2-3cb8d6daf5caf6a437d9fe66e3460833_720w.jpg" alt="源自知乎" style="zoom:150%;" /></p><h2 id="图的性质"><a href="#图的性质" class="headerlink" title="图的性质"></a>图的性质</h2><p>对于有向图，一个节点v，他有n个以它为第二元素的序偶，则它的入度为n，记作$deg^-(v)=n$反之有m个以它为第一元素的序偶，则它的出度为m，记作$deg^+(v)=m$，对于整个图中，最大度记作<code>Δ</code>，最小度记作<code>δ</code>，最大最小出入度就是分别在右上角标号。而握手定理描述的就是下面的式子：</p><script type="math/tex; mode=display">\sum^N_ndeg(v_n)=2E</script><p>含义就是所有度数加和应为边数的二倍。</p><p>对于无向图，对其任意两个结点存在一条边能相互直达，就说两点是连通的，通常用连通性矩阵P表示。如果连通性矩阵的每一个元素都是1，那么图叫做连通图，反之叫做非连通图。自然的，图的等价类所有的导出子图都被称作为连通分支。而对于连通度，如果图G满足：</p><script type="math/tex; mode=display">p(G-V'')>p(G)</script><p>则V’’叫做点割集，如果|V’’|=1则叫做割点。同理如果图G满足：</p><script type="math/tex; mode=display">p(G-E'')>p(g)</script><p>则E’’叫做边割集，如果|E’’|=1叫做桥。而根据割集元素数量和种类，就引出了连通度的概念，即k(G)=min{|V’’| | V’’是点割集}，结果就是连通度k，V’’是点，则叫j做k-连通图，反之k(G)=min{|E’’| | E’’是边割集}，结果是连通度k，叫做k边-连通图。假设一个图，如果去掉所有有向边是连通的，就说图是弱连通，如果存在一对结点时连通的，就说时单向连通，如果任意节点均可达，就说是强连通的。假设等价关系的导出子图具有连通性，并且是有强弱之分，那么就可以分别命名为强连通分支，弱连通分支和单向连通分支。</p><p>对于边是含权的，如果需要计算任意两节点间的路径长度和最短路径，就需要下面两个算法</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="dijkstra算法"><a href="#dijkstra算法" class="headerlink" title="dijkstra算法"></a>dijkstra算法</h3><p>如果你有学习过算法，你一定对他不陌生，他是通过不断转移标号，获取经过所有结点的一种算法，出于理解，我会用C++完成这个算法。dijkstra算法的思路是，从根节点开始标记为不定标签U，其余所有结点标记为变化节点V，寻找从U至V的最短路径，找到之后将最短的标记为U，重复上述步骤，直到被标记的是终点结点即可。</p><ul><li>第一步，标记根结点为U，找出与之相邻的结点路径，在距离表中保存它们的距离</li><li>第二步，在相邻结点中找出距离下一组不包含V标记的结点中路径最短的，利用V标记当前结点，计算当前结点到下一组的所有距离，保存进距离表</li><li>第三步，在未标记结点中继续寻找最短的，然后重复步骤二，直到所有点被标记完</li></ul><p><img src="http://img.51nod.com/upload/000FBEC4/08D26D026B49A4520000000000000007.png" alt="实例图"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//========================</span><br><span class="hljs-comment">// Dijkstra算法</span><br><span class="hljs-comment">// Author      : Villalba Caceres Vicente Javier</span><br><span class="hljs-comment">// Translate   : Minloha</span><br><span class="hljs-comment">// Name        : Dijkstra</span><br><span class="hljs-comment">//========================</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span>;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span>;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span>;</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><br><span class="hljs-keyword">int</span> node;<br><span class="hljs-keyword">int</span> cost;<br><span class="hljs-built_in">Edge</span>(<span class="hljs-keyword">int</span> _node, <span class="hljs-keyword">int</span> _cost) : <span class="hljs-built_in">node</span>(_node), <span class="hljs-built_in">cost</span>(_cost) &#123;&#125;<br><span class="hljs-built_in">Edge</span>() : <span class="hljs-built_in">node</span>(<span class="hljs-number">-1</span>), <span class="hljs-built_in">cost</span>(<span class="hljs-number">-1</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span>&#123;</span><br>vector&lt;Edge&gt; G[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">int</span> V = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> E = <span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">State</span>&#123;</span><br><span class="hljs-keyword">int</span> node;<br><span class="hljs-keyword">int</span> cost;<br><span class="hljs-built_in">State</span>(<span class="hljs-keyword">int</span> _node, <span class="hljs-keyword">int</span> _cost) : <span class="hljs-built_in">node</span>(_node), <span class="hljs-built_in">cost</span>(_cost) &#123;&#125;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-keyword">const</span> State&amp; b) <span class="hljs-keyword">const</span>&#123;<br><span class="hljs-keyword">return</span> cost &gt; b.cost;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">algoritmo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">const</span> Graph graph)</span></span>&#123;<br>priority_queue&lt;State&gt; pq;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">Dist</span><span class="hljs-params">(graph.V, <span class="hljs-number">0x3f3f3f3f</span>)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">mark</span><span class="hljs-params">(graph.V, <span class="hljs-literal">false</span>)</span></span>;<br><br>Dist[begin] = <span class="hljs-number">0</span>;<br>pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">State</span>(begin, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>())&#123;<br>State st = pq.<span class="hljs-built_in">top</span>(); pq.<span class="hljs-built_in">pop</span>();<br>mark[st.node] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (st.node == end)<br><span class="hljs-keyword">return</span> st.cost;<br><br><span class="hljs-keyword">int</span> T = (<span class="hljs-keyword">int</span>)graph.G[st.node].<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; T; ++i)&#123;<br><span class="hljs-keyword">if</span> (!mark[graph.G[st.node][i].node] &amp;&amp; ((Dist[st.node] + graph.G[st.node][i].cost) &lt; Dist[graph.G[st.node][i].node]))<br>&#123;<br>Dist[graph.G[st.node][i].node] = st.cost + graph.G[st.node][i].cost;<br>pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">State</span>(graph.G[st.node][i].node, st.cost + graph.G[st.node][i].cost));<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Programa</span>&#123;</span><br><span class="hljs-keyword">int</span> V, E;<br><span class="hljs-keyword">int</span> comienzo, fin;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">definirGrafo</span><span class="hljs-params">(Graph&amp; graph)</span></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;输入点数：&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; V;<br>cout &lt;&lt; <span class="hljs-string">&quot;输入边数：&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; E;<br><br>graph.V = V;<br>graph.E = E;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cargarGrafo</span><span class="hljs-params">(Graph&amp; graph)</span></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; E; ++i)&#123;<br><span class="hljs-keyword">int</span> Origen, Destino, Peso;<br>cout &lt;&lt; <span class="hljs-string">&quot;边&quot;</span> &lt;&lt; i &lt;&lt;<span class="hljs-string">&quot;的第一元素:&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; Origen;<br>cout &lt;&lt; <span class="hljs-string">&quot;边&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;的第二元素: &quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; Destino;<br>cout &lt;&lt; <span class="hljs-string">&quot;边&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;输入边的权重:&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; Peso;<br><br>graph.G[Origen].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Edge</span>(Destino, Peso));<br>graph.G[Destino].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Edge</span>(Origen, Peso));<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(Graph graph)</span></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;输入根结点: &quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; comienzo;<br>cout &lt;&lt; <span class="hljs-string">&quot;输入终点:&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; fin;<br><span class="hljs-keyword">int</span> n = <span class="hljs-built_in">algoritmo</span>(comienzo, fin, graph);<br>cout &lt;&lt; <span class="hljs-string">&quot;Dijkstra计算的距离: &quot;</span> &lt;&lt; n &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">bool</span> out = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">char</span> salir;<br><br>Programa programa;<br>Graph graph;<br><br><span class="hljs-keyword">while</span> (!out)&#123;<br>programa.<span class="hljs-built_in">definirGrafo</span>(graph);<br>programa.<span class="hljs-built_in">cargarGrafo</span>(graph);<br>programa.<span class="hljs-built_in">Dijkstra</span>(graph);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;离开?(Y/N)&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; salir;<br><span class="hljs-keyword">if</span> (salir == <span class="hljs-string">&#x27;Y&#x27;</span> || salir == <span class="hljs-string">&#x27;y&#x27;</span>) &#123;<br>out = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你可以用此算法完成自己的图与Dijkstra距离。</p><h3 id="Fluyd算法"><a href="#Fluyd算法" class="headerlink" title="Fluyd算法"></a>Fluyd算法</h3><p>这个算法的C++版本我短时间写不出来，那就只能说流程了呀~</p><ul><li>i=0，首先规定自环距离为0，然后列举所有结点的距离，不可一步到达在矩阵中记作∞</li><li>i++，保留上一步矩阵中i行i列元素和主对角线元素，将其他位置的元素与保留下来的i行i列元素加和，如果和小于原有的值，则替换，得到新矩阵（如此循环）</li><li>当i达到结点个数时，停止计算，则对应行列就是最短距离</li></ul><p>相关的公式如下：</p><script type="math/tex; mode=display">D^{(0)}=(ω_{ij})_{n×n}</script><p>规定d为D的某行某列元素，则满足：</p><script type="math/tex; mode=display">D^{(k)}=d^k_{ij}</script><p>而d的计算满足：</p><script type="math/tex; mode=display">d^{(k)}_{ij}=min[d^{(k-1)}_{ij},d^{(k-1)}_{ik}+d^{(k-1)}_{kj}]</script><p>而如果手算Floyd就十分有趣了，表示出图的加权邻接矩阵，通过保留主对角线上行列元素已经对应行与列，迭代到所有点之后，就能算出不同起点到不同终点的路径了。</p><blockquote><p>dijkstra代码源自<a href="https://github.com/jpieroabarcam/Dijkstra.git，仅仅去掉注释和汉化一下">https://github.com/jpieroabarcam/Dijkstra.git，仅仅去掉注释和汉化一下</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学基础</title>
    <link href="/2022/03/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/03/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="一-集合论"><a href="#一-集合论" class="headerlink" title="[一]集合论"></a>[一]集合论</h1><p>集合论是非常简单又基础的，在高中数学的第一章便是集合论，因为内容重复，我只说简单的提一句。</p><p>集合要有以下性质：</p><ul><li>互斥性：集合内没有重复的元素</li><li>无序性：集合内元素没有先后顺序</li><li>确定性：元素一定可以被确定是或否属于集合</li></ul><h2 id="集合的关系与运算"><a href="#集合的关系与运算" class="headerlink" title="集合的关系与运算"></a>集合的关系与运算</h2><p>集合之间主要有子集和真子集的父子关系，或者等集表示两个互为子集的集合，一般记作集合A=集合B即：A=B。集合的表达常用的有三种，描述法，列举法，Venn氏图法，描述法就是对集合内的元素的区间加以描述，比如：</p><ul><li>A={ 所有的地球人 }</li></ul><p>列举法就是列举出集合内所有元素，比如：</p><ul><li>B={ Minloha，Minloha的女朋友 }</li></ul><p>Venn氏图法可以通过直观的图形描述，这里就不举例了。</p><h2 id="集合的运算"><a href="#集合的运算" class="headerlink" title="集合的运算"></a>集合的运算</h2><p>集合运算是简单的，同样的，集合运算也适用于概率论中事件的运算。集合运算有以下几种</p><ul><li>交集：取出集合的公共部分，组成新的集合$A∩B$</li><li>并集：将集合所有元素构成一个新的集合，新集合要满足集合的性质记作$A∪B$</li><li>补集：从一个集合中取出当前集合不具有的元素，组成新的集合，记作$\bar A$或者$C^A_U$意味在全集U中的补集</li><li>差集：从一个集合中拿出另一个集合的部分，记作$A-B$,公式可以写作$A∩\bar B$意味A与B补集的交集</li></ul><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fgss2.bdstatic.com%2F-fo3dSag_xI4khGkpoWK1HF6hhy%2Fbaike%2Fs%3D220%2Fsign%3D0904009441a7d933bba8e3719d4ad194%2F86d6277f9e2f07082e8f1080ea24b899a801f2a3.jpg&amp;refer=http%3A%2F%2Fgss2.bdstatic.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650813516&amp;t=90f35beb983a64ca03f5019b0d9e577d" alt="差集"></p><ul><li>对称差集：指集合交集在并集中的补集，记作$A⊕B$，表示的集合是$(A-B)∪(B-A)$</li></ul><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/set/1.png" alt="对称"></p><p>这里主要有几个常用的公式：</p><ul><li>分配律<ul><li>$A∩(B∪C)=(A∩B)∪(A∩C)$</li><li>$A∪(B∩C)=(A∪B)∩(A∪C)$</li></ul></li><li>吸收律<ul><li>$A∩(A∪B)=A,A∪(A∩B)=A$</li></ul></li><li>德摩根律(记得变号)<ul><li>$ \overline{(A∪B)} = \bar A∩\bar B$</li></ul></li></ul><p>这些定律都可以通过Venn图表示证明，都是非常简单的。</p><h2 id="集合的限度"><a href="#集合的限度" class="headerlink" title="集合的限度"></a>集合的限度</h2><p>集合可以分为有限集和无限集，而无限集又分为<strong>可数集合</strong>和<strong>不可数集合</strong>两类，我们把映射的含义拿来定义可数集合，规定自然数集N，如果集合与N存在对应关系<code>Ψ</code>使得集合与N之间每一个元素都存在一一对应关系，那么就说这个集合是可数的。而这个运算关系，也可以理解为是在计算集合的势能，所以也可以说是集合与自然数集N等势。等势集合一般记作下面的形式：</p><script type="math/tex; mode=display">Ψ:A→B</script><script type="math/tex; mode=display">A \sim B</script><p>很像映射，也确实是一种映射关系。</p><p>如果集合A与自然数集N等势，那A是可数集合，记作$Χ_0$读作阿列夫零。同时有理数集合是可以用自然数的除法表示所有元素的，所以有理数集也是可数集合。而不可数集合就是与$(0,1)$开区间等势的集合，记作$Χ$。</p><p>而判断集合是否是可数的集合，只要找出对应的关系<code>Ψ</code>就可以了，</p><h2 id="集合的应用"><a href="#集合的应用" class="headerlink" title="集合的应用"></a>集合的应用</h2><p>集合用于描述解决方案以及列举描述元素，它主要应用于概率论中，在离散数学我们几乎只涉及其表示方法，下面是一个例题，可以参考一下</p><blockquote><p>传说在20人中，一定有10人是会编程的，10人会唱歌的，6人既会编程又会唱歌，问既不会编程又不会唱歌有几人</p></blockquote><p>可以设所有人为全集U，会编程的人组成集合A，会唱歌的组成集合B，可以写出$A∪B$,就是所有会编程和会唱歌无重复元素的集合，那么他的补集就是待证的集合，$\overline{A∪B}= |A| + |B| - |A∩B|=10+10-6=14$，那么补集大小就是20-14=<code>6</code>，所以会有6人不会编程，不会唱歌。</p><h1 id="二-计数原理"><a href="#二-计数原理" class="headerlink" title="[二]计数原理"></a>[二]计数原理</h1><p>这里在高中教材中同样有，这里的难点不是在计算，而是在思考解决问题的算式。同时在描述一些复杂的流程或者是在学习概率论的分布时，都会接触计数原理的内容。</p><p>计数原理在离散数学中主要介绍两个计算原理和两种数(排列组合)，如果感兴趣可以在文末的评论区留言，我可能会出一期排列组合的博客，讲一讲常用的排列组合模型！对高考生也是有帮助的哟~</p><h2 id="乘法与加法原理"><a href="#乘法与加法原理" class="headerlink" title="乘法与加法原理"></a>乘法与加法原理</h2><p>乘法原理主要讲的是如果一件事情需要分成若干步，每一步都有不同数目的选择，那么最终可以产生的方案就是不同步骤下选择的乘积。即$n<em>1×n_2×n_3×n</em>{….}$，举例说：Minloha要从北京到上海，再去深圳。假设北京到上海有7种交通工具可以选择，上海到深圳有8种交通工具可以选择，那么Minloha可以有几种方案到达深圳？</p><p>很简单，7×8=56就可以了，这就是乘法原理的应用</p><p>加法原理主要讲的是情况，比如处理一件事有AB两种情况，那么只需要把不同情况下的选择数加和就可以了，也可以写作为$i<em>1+i_2+i_3+i</em>{…}$，举例说：Minloha已经到达了深圳，现在Minloha要去买一台电脑，A电脑店有20台电脑，B电脑店有10台电脑，请问Minloha有多少种选择？</p><p>答案很简单，就是20+10=30，也就是把具体的情况加和</p><h2 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h2><p>排列组合主要是他的含义，排列数在高中教材被写为$A_n^m$表示从n开始向减小的方向乘以m个数字，概率意义是从n个元素中有顺序的抽取m个。计算可以看例子，比如$A_4^2$表示从4开始向后乘两位，即4×3=12，而在《离散数学及其应用第三版》中将他写作为$P_n^m$，表达的含义是一样的。对于排列的计算可以有公式：</p><script type="math/tex; mode=display">A_n^m=\frac{n!}{(n-m)!}</script><p>而组合数同样的记作为$C_n^m$表示从n个元素无顺序的取出m个，计算可以写作以下格式：</p><script type="math/tex; mode=display">C_n^m=\frac{A_n^m}{m!}=\frac{n!}{m!(n-m)!}</script><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>应用主要讲两个原理，对于高中学过排列组合的一定都背过那些模型，插空隔板什么的。</p><p>对于常用的排列组合模型，我就不细说，直接一道题看看</p><blockquote><p>将标号为1、2、3、4、5、6的张卡片放入三个不同的信箱中，如果每个信箱放两张，其中标号1、2放入一个信箱中，则不同的分发有几种？</p></blockquote><p>解析：因为1、2已经确定，则只要分3、4、5、6就可以了，则有$C_4^2C_2^2$种针对余下的新的分发，而三个信箱所放信件各不相同，所以总体结果要乘以3。</p><hr><p>答案是：$3×C_4^2C_2^2$=18种</p><h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><p>所谓容斥原理，说的其实很简单，就是人们排斥不想要的，包容想要的，但有些问题比较特殊，需要包含错误内容作为补偿，这个原理就叫容斥原理，在高中数学中主要体现在计算模型：总体剔除，定序缩倍。</p><h3 id="抽屉原理"><a href="#抽屉原理" class="headerlink" title="抽屉原理"></a>抽屉原理</h3><p>这是一个在小学学习的内容，简单的说，你有5个苹果，要放进4个抽屉中，在保证每个抽屉都有苹果的前提下，必然有一个抽屉里面有两个苹果，这就是抽屉原理。</p><p>最后简单的来一个排列组合问题，高中难度的哟！</p><blockquote><p>公司安排5位员工前往3个地点出差，要求每个人都要去，每个人只要去一个地方，请问有几种方案？</p></blockquote><p>答案是：$A_5^3$=60种方案</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一件持续时间超长的烦心事</title>
    <link href="/2022/03/18/%E4%B8%80%E4%BB%B6%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4%E8%B6%85%E9%95%BF%E7%9A%84%E7%83%A6%E5%BF%83%E4%BA%8B/"/>
    <url>/2022/03/18/%E4%B8%80%E4%BB%B6%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4%E8%B6%85%E9%95%BF%E7%9A%84%E7%83%A6%E5%BF%83%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>说明</p></blockquote><p>Minloha还算比较喜欢研究人类心理或者人类思想，不过自己也算是人类，研究自己也算是可以吧，做做黑盒测试~</p><h2 id="讲述"><a href="#讲述" class="headerlink" title="讲述"></a>讲述</h2><p>说真的，从2021年10月24号开始我就开始为了这件小事闹心了。其实在我刚上高中的时候我的三观还没有现在这么硬，还是保留着那种<code>自傲</code>的性子，然后可能是自我意识过剩吧，我最开始的想法是过一个完满的高中生活，至少别重复初中那种另类的孤独，把自己高高挂起，当一个旁观者，过完高中就完事。然后这个10月24号，我就违背了这个初心，尝试带了一个异性同学，也可能是欲求不满吧，也算是受到了刺激，寻思能不能考一个大学这种浪漫的事情（单纯的幻想….）不过遗憾的是，被拒绝了，不过我可以理解，毕竟分数相差太多了，我本身也不见得会以牺牲自己前途换取一段说不准的爱情吧。不过理性是理性，感性是感性，我终于在一次月假时表明了心意，不过并未得到肯定的答复，还算是挺意外的(我还蛮有信心)，不过拒绝就拒绝吧，强求也不好。后来自己也犹豫了几次，不过也许是自己还算是赌徒心理吧，也就暂时。然后就是这篇博文发出的同一天，我终于是受不了了，简单思考一下觉得：“为什么要这么做啊？利益呢，经历呢，能力呢？三立都不满足，还干嘛？更何况你不应该找一个符合你的而不是去符合一个吗？多掉价。”然后现在就放弃了呗。不过还挺有趣的，多了一些奇妙的经历，还算有趣吧，总不能作为一具空壳吧！说起细节也是没有太越界的事情，只能说是差点意思。</p><p>其实这些事并不是答案唯一的嘛，我寻思就算无法达到一些超越的关系，好得也得让我见到利益啊，要不然我就迷茫了，所以我寻思，就算是谢谢或者是给我弄点吃的也可以(真好对付)，结果全都没有，我最无法理解的就是这个了，挺纳闷还有点生气吧，毕竟就算是补课教师，也没有做到这种程度的呀！说真的，我有这时间，开一个月卡价位的小私塾不更好嘛！只能说掉价！</p><p>其实我不太希望改变之前的关系，不过我真心有点遭不起了，我只能说真的麻烦，如果有需要的话，你还是自己另谋生路吧，Minloha不是实现人愿望的神，而是在知晓愿望后，带着你的愿望丢下你前行的人。</p><h2 id="升华一下"><a href="#升华一下" class="headerlink" title="升华一下"></a>升华一下</h2><p>其实在我写这些时，我内心并不算太波澜，因为我本身也就没有太多希望吧，我也没有过希望什么的，唯一的感觉就是浪费了一些时间做了一件没什么意义的事情，就像一次考试中的漫画作文一样：“人们总会在头脑一热的时候做一些傻事，供平静下来反思”，现在我就是平静下来了呗，不过也无妨，在有限的时间里，我又多做了一件事，也还算是有意义吧！（自我安慰）</p><p>这145天挺神奇的，我说过我是好脾气，但不代表我没脾气，也不是没有就活不了，不过就算如此，我也得说，老子也不是公交车，一块两块就乐呵，我只想要我想要的，不想被改变，现在我依然怀有热心，不过再也不会自己主动了，而是等着一个真正值得的人。</p><p>其实自己也没有做太多过分的事情，其实之前看过一段小视频，我也算是受到了刺激才这样做的，现在如果我不存在过，继续让你在黑暗中挣扎，估计会更有趣，所以我现在就很闹心与我毁掉了一个趣事，因为我本身也不是什么正义人啊。当然切实际的讲，既然有能力拔出来，也有能力踩回去，天上地下的感受或者恶毒的黑心的等等词汇都可以形容我吧，反正只要我快乐就好，想到这里我就很快乐了。</p><p>其实说出来的目的很明确，就是希望自己惊醒或者是当作自己的羞耻记录，让自己别再出现奇奇怪怪的心理，因为这些东西很麻烦，耽误事。也是后来的年轻人能够切实感受到一种夹缝的感觉。</p><h2 id="感悟一下"><a href="#感悟一下" class="headerlink" title="感悟一下"></a>感悟一下</h2><p>我就不应该彰显自己的能力，寻思自己能和某人一起学习，我本身就是从外向硬掰过来的，我也深知外向的后果，无论别人如何都和我无关，最后只要我胜利就可以了，别的我都不要。</p><blockquote><p>稍微平复了一下</p></blockquote><p>静下心了，一去思考也就没什么问题了，这么一看也确实不合适，再继续下去，死人都会气的蹦起来，也就当在最后的几天里做了一件违心的事情吧~</p>]]></content>
    
    
    <categories>
      
      <category>新事物</category>
      
    </categories>
    
    
    <tags>
      
      <tag>三观</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性方程组的系数增广矩阵解决盖斯定律</title>
    <link href="/2022/02/27/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E7%B3%BB%E6%95%B0%E5%A2%9E%E5%B9%BF%E7%9F%A9%E9%98%B5%E8%A7%A3%E5%86%B3%E7%9B%96%E6%96%AF%E5%AE%9A%E5%BE%8B/"/>
    <url>/2022/02/27/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E7%B3%BB%E6%95%B0%E5%A2%9E%E5%B9%BF%E7%9F%A9%E9%98%B5%E8%A7%A3%E5%86%B3%E7%9B%96%E6%96%AF%E5%AE%9A%E5%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="线性方程组和矩阵"><a href="#线性方程组和矩阵" class="headerlink" title="线性方程组和矩阵"></a>线性方程组和矩阵</h1><blockquote><p>线性方程组</p></blockquote><p>在中学的学习阶段，我们会接触到直线方程与直线系，它们都可以用一串简单的方程表示。</p><script type="math/tex; mode=display">Ax+By+C=0</script><p>而线性方程和直线方程十分类似，假设有一个含有n个变量的方程，它的形式是这样的。这是线性方程的通用格式</p><script type="math/tex; mode=display">\sum^n_{i=1}a_ix_i=b\\a_1x_1+a_2x_2+a_3x_3+....+a_nx_n=b\\</script><p>而线性方程组就是把多个线性方程列举出来，如果这些线性方程之间在n维空间上存在公共区域，那就说这些线性方程之间相容。当然公共区域可以是点，也可以直线，如果是一个多元函数的话，也可以是一个平面</p><blockquote><p>矩阵</p></blockquote><p>矩阵是线性代数主要研究对象，它具有以下特征。</p><ul><li>具有一定范围的行与列</li><li>至少含有一个非零元素的行或列</li><li>表示n维空间时就会有n列</li></ul><p>矩阵的写法如下：当然，如果我要表示矩阵第i行j列就可以用表示$A_{ij}$(矩阵和行列式不是一个东西哦~)</p><script type="math/tex; mode=display">A=\left[\begin{matrix}3&2&1\\6&8&7\\9&-1&2\end{matrix} \right]</script><blockquote><p>线性方程的系数矩阵</p></blockquote><p>那么对于一个线性方程而言，它的关键元素就是每一个x前面的系数，也就是线性方程的特征，我们按照一定的次序把这些特征放入一个矩阵中，得到的矩阵就叫线性方程的系数矩阵或者特征矩阵。</p><script type="math/tex; mode=display">a_1x_1+a_2x_2+a_3x_3=M\\</script><script type="math/tex; mode=display">b_1x_1+b_2x_2+b_3x_3=N\\</script><p>对于每一个x_1都有不同的系数,可以写出系数矩阵A</p><script type="math/tex; mode=display">A=\left[\begin{matrix}a_1&a_2&a_3\\b_1&b_2&b_3\\\end{matrix} \right]</script><p>如果包含等号的右半部分，就说A是线性方程组的增广矩阵</p><script type="math/tex; mode=display">A=\left[\begin{matrix}a_1&a_2&a_3&M\\b_1&b_2&b_3&N\\\end{matrix} \right]</script><h1 id="盖斯定律"><a href="#盖斯定律" class="headerlink" title="盖斯定律"></a>盖斯定律</h1><p>盖斯定律出现在选修——化学反应原理中，主要用于计算热化学方程式的放热。它有一个功能，多步化学反应放热等于总反应的放热，下面是一个盖斯定律应用的例子</p><script type="math/tex; mode=display">As_{(s)}+\frac{3}{2}H_{2(g)}+2O_{2(g)}=H_3AsO_{4(s)}→ΔH_1</script><script type="math/tex; mode=display">H_{2(g)}+\frac{1}{2}O_{2(g)}=H_2O_{(l)}→ΔH_2</script><script type="math/tex; mode=display">2As_{(s)}+\frac{5}{2}O_{2(g)} =As_2O_{5(s)}→ΔH_3</script><script type="math/tex; mode=display">求证As_2O_{5(s)} +3H_2O_{(l)} = 2H_3AsO_{4(s)}→ΔH</script><p>这是一道2017年的全国三卷题，它看起来很复杂，所以我就拿来了，现在就是用线性方程解决它的时候了</p><p>为了方便表示，我们可以先设几个字母，方便我们书写</p><ul><li>$As=x_1$</li><li>$H_2=x_2$</li><li>$O_2=x_3$</li><li>$H_3AsO_4=x_4$</li><li>$H_2O=x_5$</li><li>$As_2O_5=x_6$</li></ul><p>那么对于已知的条件可以写成下面的形式</p><script type="math/tex; mode=display">x_1+\frac{3}{2}x_2+2x_3=x_4\\x_2+\frac{1}{2}x_3=x_5\\2x_1+\frac{5}{2}x_3=x_6\\</script><p>转化为矩阵$[x_1,x_2,x_3,x_4,x_5,x_6]$的格式</p><script type="math/tex; mode=display">x_1+\frac{3}{2}x_2+2x_3-x_4+0x_5+0x_6=ΔH_1\\</script><script type="math/tex; mode=display">0x_1+x_2+\frac{1}{2}x_3+0x_4-x_5+0x_6=ΔH_2\\</script><script type="math/tex; mode=display">2x_1+0x_2+\frac{5}{2}x_3+0x_4+0x_5-x_6=ΔH_3\\</script><p>对于要求证的方程式,我们也用线性方程的形式表示出来</p><script type="math/tex; mode=display">\left[\begin{matrix}1&\frac{3}{2}&2&-1&0&0&ΔH_1\\0&1&\frac{1}{2}&0&-1&0&ΔH_2\\2&0&\frac{5}{2}&0&0&-1&ΔH_3\\\end{matrix} \right]</script><p>代证方程:</p><script type="math/tex; mode=display">x_6+3x_5=2x_4\\</script><script type="math/tex; mode=display">0x_1+0x_2+0x_3-2x_4+3x_5+x_6=ΔH\\</script><p>用矩阵表示一下</p><script type="math/tex; mode=display">\left[\begin{matrix}0&0&0&-2&3&1&ΔH\end{matrix} \right]</script><p>这就是我们的目标矩阵</p><script type="math/tex; mode=display">\left[\begin{matrix}0&0&0&-2&3&1&ΔH\end{matrix} \right]</script><p>对与矩阵，我们进行<em>行化简</em>，找主元列，目标方程没有x1,x2,x3，而一三有，所以一式扩大二倍减去三式</p><script type="math/tex; mode=display">\left[\begin{matrix}2&3&4&-2&0&0&2ΔH_1\\0&1&\frac{1}{2}&0&-1&0&ΔH_2\\2&0&\frac{5}{2}&0&0&-1&ΔH_3\\\end{matrix} \right]\\</script><script type="math/tex; mode=display">2ΔH_1-ΔH_3=\\\left[\begin{matrix}0&3&\frac{3}{2}&-2&0&1&2ΔH_1-ΔH_3\\\end{matrix} \right]\\</script><p>继续化简，目标式没有x2,x3，而二式可以与算出来的$2ΔH_1-ΔH_3$化简一下，我们结合目标矩阵看$x_5$，从-1变成3，要乘以-3然后得到下面的形状</p><script type="math/tex; mode=display">\left[\begin{matrix}0&-3&-\frac{3}{2}&0&3&0&-3ΔH_2\\\end{matrix} \right]\\</script><p>我们结合一下现有的方程就可以算出结果了</p><script type="math/tex; mode=display">\left[\begin{matrix}0&3&\frac{3}{2}&-2&0&1&one\\\end{matrix} \right]\\</script><script type="math/tex; mode=display">\left[\begin{matrix}0&-3&-\frac{3}{2}&0&3&0&two\\\end{matrix} \right]\\</script><script type="math/tex; mode=display">\left[\begin{matrix}0&0&0&-2&3&1&three\end{matrix} \right]</script><p>我们这时惊讶的发现，第一步的结果和第二步的结果相加，正好是第三待证结论，所以</p><script type="math/tex; mode=display">ΔH=(2ΔH_1-ΔH_3)-3ΔH_2</script><p>没错，结果出来了，对于一些非常复杂，或者结果带有奇奇怪怪系数的题目，这种办法很有效</p><blockquote><p>最后补充</p></blockquote><p>线性方程的行变换还可以转换为阶梯矩阵，如果感兴趣的话，也可以尝试使用向量空间与线性方程组做乘法，看看会不会出现n维公共部分，一样可以求解。</p>]]></content>
    
    
    <categories>
      
      <category>学业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>化学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搓搓C++的指针</title>
    <link href="/2022/02/07/%E6%90%93%E6%90%93C++%E7%9A%84%E6%8C%87%E9%92%88/"/>
    <url>/2022/02/07/%E6%90%93%E6%90%93C++%E7%9A%84%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>指针是一种底层的数据类型，可以实现对各种内存的操作，无论内存是位于栈上还是堆上，有权限就可以操作。如果说变量是盒子，那指针就是盒子的编号或者标签，<code>*</code>就是一种表示指针的操作符。</p><p>指针可以根据描述对象分为很多种，但是其本质就是一种表达内存的数据。一个非野指针或非空指针变量会拥有两个内存地址，一个是本身位于栈上的内存地址，另一个是其指向的内存地址。</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/efi/pointer.png" alt=""></p><p>为了解释的更具体，Minloha采购了<code>C Primer Plus</code>并且深入的和书籍交流了一番，做出以下解释</p><h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><p>结构体指针就是指向一个结构体变量的指针，其调用都可以像正常结构体对象一样。先写出一个结构体并实现结构体指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> number;<br>&#125; T;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>T.number = <span class="hljs-number">123123</span>;<br><span class="hljs-comment">//使用已有的结构对象作为指针的指向</span><br>A* p = &amp;T;<br><span class="hljs-comment">//从栈中分配出新的区域作为指针指向</span><br>A* p2 = <span class="hljs-keyword">new</span> A;<br><span class="hljs-comment">//分别修改各自的内容</span><br>p-&gt;number = <span class="hljs-number">114514</span>;<br>p2-&gt;number = <span class="hljs-number">123</span>;<br><span class="hljs-comment">//T中原本保留的内容[123123]被修改为[114514]</span><br>cout &lt;&lt; T.number &lt;&lt; endl;<br><span class="hljs-comment">//p2内容正常输出:123</span><br>cout &lt;&lt; p2-&gt;number &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>对结构体<code>A</code>,在它声明的同时也创建了一个对象<code>T</code>，这个对象可以被一个同为<code>A</code>的指针指向，这个指针就叫结构体指针，也就是代码中的<code>*p</code>，指针的初始化可以通过取值符<code>&amp;</code>取已有对象的地址。</p><p>底层的说是不存在变量什么的，都是内存地址的移动，所以当指针被一个对象地址初始化之后，指针就是对象了，之后对指针的增删改都会直接影响到对象，因为它们两个是在一个内存上生长的。</p><h2 id="野指针-amp-空指针-amp-无类型指针"><a href="#野指针-amp-空指针-amp-无类型指针" class="headerlink" title="野指针&amp;空指针&amp;无类型指针"></a>野指针&amp;空指针&amp;无类型指针</h2><p>野指针是一种指向地址不确定的指针，空指针就是指向地址为空的指针，无类型指针就是用<code>void</code>定义的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> num = <span class="hljs-number">114514</span>;<br>    <span class="hljs-comment">//三种声明指针的方法</span><br><span class="hljs-keyword">void</span>* a = &amp;num;<br><span class="hljs-keyword">int</span>* b = &amp;num;<br><span class="hljs-keyword">int</span>* c = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//</span><br><span class="hljs-comment">//void*是无类型指针,可以指向任何数据类型,输出时要进行强制转换</span><br>cout &lt;&lt; *(<span class="hljs-keyword">int</span>*) a &lt;&lt; endl;<br><span class="hljs-comment">//正常指针类型</span><br>cout &lt;&lt; *b &lt;&lt; endl;<br><span class="hljs-comment">//*c的定义是从栈中随机取出的,所以输出内容就非常不可懂了</span><br>cout &lt;&lt; *c &lt;&lt; endl;<br><span class="hljs-comment">//释放内存空间,*c变成了野指针</span><br><span class="hljs-comment">//释放内存空间也可以用   delete c;</span><br><span class="hljs-built_in">free</span>(c);<br>cout &lt;&lt; *c &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>在内存管理部分中要尽可能避免这小部分提到的指针，主要是为了保证内存的安全性。</p><h2 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h2><p>数组的定义是<code>int array[]</code>，而这个<code>array</code>就是一种数组指针，指向了数组头</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> list[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span> &#125;;<br><span class="hljs-keyword">int</span>* p = list;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>;i++) &#123;<br>cout &lt;&lt; p[i] &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针与指针函数一直被区分着，其实可以用偏意词的角度理解，函数指针即指向函数的指针，指针函数就是返回值为指针的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//这是一个指针函数,返回值是int*类型</span><br><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>*)n;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; *<span class="hljs-built_in">func</span>(<span class="hljs-number">9</span>) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数指针的写法是<code>类型 (*指针名)(参数表)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a-b;<br>&#125;<br><span class="hljs-comment">//这是函数指针</span><br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*func)(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b);<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//函数指针可以被函数名初始化(换个角度,函数名就是函数指针)</span><br>    func = add;<br>    cout &lt;&lt; <span class="hljs-built_in">func</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>) &lt;&lt; endl;<span class="hljs-comment">//输出:3</span><br>    func = sub;<br>    cout &lt;&lt; <span class="hljs-built_in">func</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>) &lt;&lt; endl;<span class="hljs-comment">//输出:1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h2><p>指针也是一种数据类型，也会在栈中留下自己的地址，而指向指针地址的指针就叫二级指针，无限套娃下去就会出现各种等级的指针，这里说说二级指针。</p><p>在出现函数传参为指针的时候需要注意，函数所传的指针是以引用的形式传递，意味着离开函数后不会对原有指针产生任何影响，这时就需要二级指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//无法修改案例</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> gb = <span class="hljs-number">4</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getAddress</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *q)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;函数内:q=&quot;</span> &lt;&lt; q &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; <span class="hljs-string">&quot;&amp;q=&quot;</span> &lt;&lt; &amp;q &lt;&lt; endl;<br>    q = &amp;gb;<br>    cout &lt;&lt; <span class="hljs-string">&quot;函数内:q=&quot;</span> &lt;&lt; q &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; <span class="hljs-string">&quot;&amp;q=&quot;</span> &lt;&lt; &amp;q &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">3</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;num=&quot;</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; <span class="hljs-string">&quot;&amp;num=&quot;</span> &lt;&lt; &amp;num &lt;&lt; endl;<br>    <span class="hljs-keyword">int</span>* p = &amp;num;<br>    <span class="hljs-built_in">getAddress</span>(p);<br>    cout &lt;&lt; <span class="hljs-string">&quot;p=&quot;</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; <span class="hljs-string">&quot;&amp;p=&quot;</span> &lt;&lt; &amp;p &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//----------------------------------------------------------</span><br>控制台输出:<br>num=<span class="hljs-number">3</span>|&amp;num=<span class="hljs-number">00000045030F</span>FB34<br>函数内:q=<span class="hljs-number">00000045030F</span>FB34|&amp;q=<span class="hljs-number">00000045030F</span>FB10<br>函数内:q=<span class="hljs-number">00007F</span>F75DD5D000|&amp;q=<span class="hljs-number">00000045030F</span>FB10<br>p=<span class="hljs-number">00000045030F</span>FB34|&amp;p=<span class="hljs-number">00000045030F</span>FB58<br></code></pre></td></tr></table></figure><p>此时的<code>p</code>指向的地址并未被修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//使用二级指针成功案例</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> gb = <span class="hljs-number">4</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getAddress</span><span class="hljs-params">(<span class="hljs-keyword">int</span> **q)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;函数内:q=&quot;</span> &lt;&lt; q &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; <span class="hljs-string">&quot;&amp;q=&quot;</span> &lt;&lt; &amp;q &lt;&lt; endl;<br>    *q = &amp;gb;<br>    cout &lt;&lt; <span class="hljs-string">&quot;函数内:q=&quot;</span> &lt;&lt; q &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; <span class="hljs-string">&quot;&amp;q=&quot;</span> &lt;&lt; &amp;q &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">3</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;&amp;gb=&quot;</span> &lt;&lt; &amp;gb &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; <span class="hljs-string">&quot;&amp;num=&quot;</span> &lt;&lt; &amp;num &lt;&lt; endl;<br>    <span class="hljs-keyword">int</span>* p = &amp;num;<br>    <span class="hljs-built_in">getAddress</span>(&amp;p);<br>    cout &lt;&lt; <span class="hljs-string">&quot;p=&quot;</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; <span class="hljs-string">&quot;&amp;p=&quot;</span> &lt;&lt; &amp;p &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//-------------------------------------------------------------</span><br>控制台输出:<br>&amp;gb=<span class="hljs-number">00007F</span>F6F5CBD000|&amp;num=<span class="hljs-number">00000051B</span>A2FF9C4<br>函数内:q=<span class="hljs-number">00000051B</span>A2FF9E8|&amp;q=<span class="hljs-number">00000051B</span>A2FF9A0<br>函数内:q=<span class="hljs-number">00000051B</span>A2FF9E8|&amp;q=<span class="hljs-number">00000051B</span>A2FF9A0<br>p=<span class="hljs-number">00007F</span>F6F5CBD000|&amp;p=<span class="hljs-number">00000051B</span>A2FF9E8<br></code></pre></td></tr></table></figure><p>可以明显看到经过函数操作后传递的参数<code>&amp;p</code>指向被修改为<code>gb</code>的地址了，在函数内直接通过指针的地址实现的二级指针修改了参数指针指向地址……(嗯)</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>挺复杂的，但是理解之后很爽！非常建议收藏保存。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++的Lambda表达式</title>
    <link href="/2022/02/05/C++%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/02/05/C++%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>从C++11开始引入了lambda表达式，结合其他语言的定义，Lambda表达式，也被称之为匿名函数，可以实现类似的函数的功能，实现函数式编程的概念，是现代编程语言的特点之一，可以与操作符重载括号得到的伪函数关联记忆。具体的定义方法如下。既然是对象自然也就可以<code>new</code>出来内存空间（区分Java，可不是对象😂）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> 对象名 = [捕获列表](参数列表)&#123;函数体&#125;;<br></code></pre></td></tr></table></figure><h2 id="说说λ"><a href="#说说λ" class="headerlink" title="说说λ"></a>说说λ</h2><p>从一段简单的代码说起，根据面向对象的概念lambda表达式也是一种对象，它的类型是<code>auto</code>，所以它的语法要这么写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//lambda表达式</span><br>    <span class="hljs-keyword">auto</span> lambda = []() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; endl;<br>    &#125;;<br>    <span class="hljs-built_in">lambda</span>();<br>&#125;<br><span class="hljs-comment">//-------------------------------------</span><br>控制台输出:<br>hello world<br></code></pre></td></tr></table></figure><p>含参类型的lambda可以通过仿函数的写法调用，具体实现可以用操作符重载实现，这里简单写一写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//lambda表达式</span><br>    <span class="hljs-keyword">auto</span> lambda = [](<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;结果为:&quot;</span> &lt;&lt; a+b &lt;&lt; endl;<br>    &#125;;<br>    <span class="hljs-built_in">lambda</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-comment">//--------------------------------------</span><br>控制台输出:<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">lambda</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">lambda</span>(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b) &#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br><span class="hljs-keyword">this</span>-&gt;b = b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;加和为:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;a+<span class="hljs-keyword">this</span>-&gt;b &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">int</span> b;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//差不多是这个意思</span><br><span class="hljs-function">lambda <span class="hljs-title">m</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-built_in">m</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>既然lambda可以无名使用，<code>auto</code>的存在也就没那么重要了，也就是可以省略。而表达式内需要用到参数的就要在小括号内加入参数，方括号内的是执行捕获列表，常用的有<code>&amp;</code>引用捕获、<code>=</code>复制捕获、<code>this</code>指针捕获。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//等待捕获的变量</span><br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> y = <span class="hljs-number">2</span>;<br><span class="hljs-comment">//不同类型的捕获，结果不同</span><br>    <span class="hljs-keyword">auto</span> lambda1 = []() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;空捕获&quot;</span> &lt;&lt; endl;<br>    &#125;;<br>    <span class="hljs-keyword">auto</span> lambda2 = [=]() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;=捕获&quot;</span> &lt;&lt; x &lt;&lt; y &lt;&lt; endl;<br>    &#125;;<br>    <span class="hljs-keyword">auto</span> lambda3 = [&amp;]() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;&amp;捕获&quot;</span> &lt;&lt; x &lt;&lt; y &lt;&lt; endl;<br>    &#125;;<br>    <span class="hljs-keyword">auto</span> lambda4 = [&amp;x]() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;&amp;x捕获&quot;</span> &lt;&lt; x &lt;&lt;  endl;<br>    &#125;;<br>    <span class="hljs-keyword">auto</span> lambda5 = [&amp;y]() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;&amp;y捕获&quot;</span> &lt;&lt;  y &lt;&lt; endl;<br>    &#125;;<br>    <span class="hljs-keyword">auto</span> lambda6 = [x,y]() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;x,y捕获&quot;</span> &lt;&lt; x &lt;&lt; y &lt;&lt; endl;<br>    &#125;;<br>    <span class="hljs-keyword">auto</span> lambda7 = [&amp;x,y]() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;&amp;x,y捕获&quot;</span> &lt;&lt; x &lt;&lt; y &lt;&lt; endl;<br>    &#125;;<br>    <span class="hljs-keyword">auto</span> lambda8 = [x, &amp;y]() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;x,&amp;y捕获&quot;</span> &lt;&lt; x &lt;&lt; y &lt;&lt; endl;<br>    &#125;;<br>    <span class="hljs-built_in">lambda1</span>();<br>    <span class="hljs-built_in">lambda2</span>();<br>    <span class="hljs-built_in">lambda3</span>();<br>    <span class="hljs-built_in">lambda4</span>();<br>    <span class="hljs-built_in">lambda5</span>();<br>    <span class="hljs-built_in">lambda6</span>();<br>    <span class="hljs-built_in">lambda7</span>();<br>    <span class="hljs-built_in">lambda8</span>();<br>&#125;<br><span class="hljs-comment">//------------------------------------------</span><br>输出控制台:<br>空捕获<br>=捕获<span class="hljs-number">12</span><br>&amp;捕获<span class="hljs-number">12</span><br>&amp;x捕获<span class="hljs-number">1</span><br>&amp;y捕获<span class="hljs-number">2</span><br>x,y捕获<span class="hljs-number">12</span><br>&amp;x,y捕获<span class="hljs-number">12</span><br>x,&amp;y捕获<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>方括号内的格式，决定了匿名函数外部的变量是否可以被函数内部访问到，留空意味什么都不捕获，<code>=</code>就是复制一份访问不可修改，<code>&amp;</code>就是引用变量可以修改。</p><p>在多线程中，也可以使用lambda创建线程，写法简便</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//Thread</span><br>    <span class="hljs-function">thread <span class="hljs-title">thread1</span><span class="hljs-params">([] &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-comment">//通过lambda创建线程对象.</span></span></span><br><span class="hljs-function"><span class="hljs-params">        cout &lt;&lt; <span class="hljs-string">&quot;thread1&quot;</span> &lt;&lt; endl;</span></span><br><span class="hljs-function"><span class="hljs-params">        &#125;)</span></span>;<br>    <br>    thread1.<span class="hljs-built_in">join</span>();<br>&#125;<br><span class="hljs-comment">//--------------------------------</span><br>thread1<br></code></pre></td></tr></table></figure><blockquote><p>结束</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>老番推荐：《异度侵入》</title>
    <link href="/2022/02/02/%E8%80%81%E7%95%AA%E6%8E%A8%E8%8D%90%EF%BC%9A%E3%80%8A%E5%BC%82%E5%BA%A6%E4%BE%B5%E5%85%A5%E3%80%8B/"/>
    <url>/2022/02/02/%E8%80%81%E7%95%AA%E6%8E%A8%E8%8D%90%EF%BC%9A%E3%80%8A%E5%BC%82%E5%BA%A6%E4%BE%B5%E5%85%A5%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="开篇先吹水"><a href="#开篇先吹水" class="headerlink" title="开篇先吹水"></a>开篇先吹水</h2><p>《异度侵入》全名《异度侵入 ID:INVADED》，属于推理悬疑带有科幻元素类型的番剧，故事主要讲述了男主<code>酒井户</code>在虚拟世界帮助现实世界的警察破案的故事，全集13集，既不给人臃肿的叙事，也不让人感觉无法理解故事的背景，总体上非常不错</p><p>这个番剧我看了一晚上（也就是熬夜到3点看完的），很多内容令我印象深刻。全剧可以分出几条线索：</p><p>​    1、男主的个人经历</p><p>​    2、<code>井</code>和<code>罔象女</code>的来历</p><p>​    3、找到<code>约翰·沃克</code>并抓住</p><p>其中令我印象最深刻的就是第一点，男主的经历。</p><h2 id="男主的经历"><a href="#男主的经历" class="headerlink" title="男主的经历"></a>男主的经历</h2><p>男主本来是普通的一名警察，在<code>单挑</code>的案件中，女儿被残忍杀害，而老婆因为无法接受事实选择自杀，最终男主变的情绪低沉，成为了<code>罔象女</code>的操作者。全剧的高潮便是<code>井中井</code>男主与死去的妻子与女儿生活的场景，让人感受到了一个家庭的温度(虽然是早已破碎的家庭)。男主在受到另一个同为<code>罔象女</code>操作者同事的刺激后，展现了自己作为侦探强大的理解能力，主动的从虚拟的世界中抽出，毅然决然的与妻子和女儿告别，令人十分感动。</p><p>男主在<code>井</code>中的身份是侦探，在<code>井</code>外的世界中，警察通过观察男主的行为推测嫌疑人，达到破案的目的。</p><h2 id="井和罔象女的来历"><a href="#井和罔象女的来历" class="headerlink" title="井和罔象女的来历"></a>井和罔象女的来历</h2><p>在<code>井中井</code>的世界中，男主在<code>单挑</code>家中地上室发现了<code>飞鸟井木记</code>，<code>飞鸟井木记</code>就是实现<code>罔象女</code>的核心部分，而<code>井</code>就是杀人犯残留现场的杀意变幻出的虚拟空间。</p><blockquote><p>更多细节内容请看原作</p></blockquote><h2 id="谈谈男主"><a href="#谈谈男主" class="headerlink" title="谈谈男主"></a>谈谈男主</h2><p>全剧我最关心的就是男主，因为他身上充满的各种秘密，而且作为推理番，能让观众代入推理的剧情中的角色无疑是最好的。</p><p>最令我感动的就是男主承担的责任，从点滴积累出美满的家庭开始，到一切破灭，男主一直就是孤身一人，或许一般人都挺不住了吧，代入我自己，这是非常困难的。当自己喜爱的人因死亡而离自己远去，无论是谁都会伤心吧(杠精退散)。</p><h2 id="推荐理由"><a href="#推荐理由" class="headerlink" title="推荐理由"></a>推荐理由</h2><p>1、剧情连贯，人物刻画生动细腻，没有过多的矫情，更多的是作为侦探的果断</p><p>2、构思巧妙，想象内容有理有据，没有为了犯罪而犯罪的犯人，都是具有独立意识的个体</p><p>3、观点明确，没有出现热锅蚂蚁的窘境。</p>]]></content>
    
    
    <categories>
      
      <category>番剧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>三观</tag>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论现在的春晚</title>
    <link href="/2022/01/31/%E8%AE%BA%E7%8E%B0%E5%9C%A8%E7%9A%84%E6%98%A5%E6%99%9A/"/>
    <url>/2022/01/31/%E8%AE%BA%E7%8E%B0%E5%9C%A8%E7%9A%84%E6%98%A5%E6%99%9A/</url>
    
    <content type="html"><![CDATA[<h2 id="陈述观点"><a href="#陈述观点" class="headerlink" title="陈述观点"></a>陈述观点</h2><p>不可否认的是，现在的春晚确实越来越没得看了。但是我说的无论指代的是内容，而不是演员的演技或者是演员的热情等等，我就简单举几个例子，你就都懂了。</p><p>在很久很久以前，每年春晚我最期待的就是小品，因为生动幽默，并且诙谐，每年春晚都能造出几个梗，用于人们面对面交流时活跃气氛。现在的小品就失去的造梗的能力，更多的是想向大家传递一种价值观，一种感动就可以收获人们关注的价值观。或许是因为疫情的影响吧，2022年的小品居然描写了一个抗疫故事，而且还是催泪向的…..给我的感觉就很梦幻，为什么要催泪？</p><p>所以我发现，现在的春晚变成了价值观传播的工具，而不是那个给人们团圆时活跃气氛的节目了。查阅了一下十九大的内容，没想到春晚就是在响应国家的号召……</p><blockquote><p>坚持正确舆论导向，高度重视传播手段建设和创新，提高新闻舆论传播力、引导力、影响力、公信力</p></blockquote><p>除夕是一年中最后的一天，一般都是家家户户团圆的日子，本来是高高兴兴的日子，结果看了春晚各种<code>感人</code>的故事后，原本热热闹闹，欢快的叙事氛围，都被春晚<code>感人</code>的故事改变了，家人们都陷入了思考中，而不会去关注身边的人。所以，目的就偏了。</p><h2 id="给个甜枣-来一巴掌"><a href="#给个甜枣-来一巴掌" class="headerlink" title="给个甜枣(来一巴掌)"></a>给个甜枣(来一巴掌)</h2><p>不可否认，春晚拉近了人与人的距离，让人们在一起能有共同话题，而不是唠一年中的各种烦心事，包括我在内哈。就算没有春晚在，人与人的关系都还在，人与人对话的思路也都在，所以春晚不能让不熟悉的人变的熟悉，只能让熟悉的的人更加熟悉，能和喜欢的人或者能和自己所珍视的人在一起，就算不是过年也是幸福的。</p><p>任何日子或者任何时间，只要存在回忆或者事件，那它就是节日，无论是好的节日还是坏的节日，日期都是一个，都是人们赋予的含义，而所作的事情也应该迎合日子的含义，就比如清明节应该是祭祖的日子，可是非得有人不迎合节日含义，选择办一些喜事。现在的春晚便是如此，为什么要在喜庆的节日里选择这么多让人流泪的节目，难道说，过年还要哭两下吗？难道不能开开心心的过个好年吗？</p><p>春晚这东西，更多的是形式，营造出举国同庆的喜庆，让大家感受到看不见摸不到，但却是存在的热闹氛围，换句话说，在这个大氛围中，人人都是参与其中的人。</p><p>对于已经存在的问题，最好的解决办法就是从思路上改变，把春晚当作举国欢庆的节日，而不是作为价值观传播工具，制作方应该对春晚节目内容抱有热情，而不是为了时长而时长，就连相声都是旧梗新说，让人感到厌倦，丝毫没有新意。</p><hr><p>结尾来两句对自己的祝福吧，心想事成，学业进步！</p>]]></content>
    
    
    <categories>
      
      <category>新事物</category>
      
    </categories>
    
    
    <tags>
      
      <tag>三观</tag>
      
      <tag>新鲜事</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入EFI了解背后的运行</title>
    <link href="/2022/01/31/%E6%B7%B1%E5%85%A5EFI%E4%BA%86%E8%A7%A3%E8%83%8C%E5%90%8E%E7%9A%84%E8%BF%90%E8%A1%8C/"/>
    <url>/2022/01/31/%E6%B7%B1%E5%85%A5EFI%E4%BA%86%E8%A7%A3%E8%83%8C%E5%90%8E%E7%9A%84%E8%BF%90%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="EFI介绍"><a href="#EFI介绍" class="headerlink" title="EFI介绍"></a>EFI介绍</h2><p>EFI全名Extended Firmware Interface，一种应用于固态硬盘的启动引导，作为Bios后新发展的PC扩展接口升级。在Windows系统安装中，会在硬盘分出一片区域，名字就是efi，用于引导系统的启动（之前我卸载过这个分区，印象很深）</p><p>对于更多EFI启动的流程可以看下面的图片，里面包含了一套完整的EFI周期<br><img src="https://img2020.cnblogs.com/blog/1145982/202112/1145982-20211210214355937-836254628.png" alt=""></p><p>更多的EFI介绍可以参考百度，现在不关心历史只关系用处🤣</p><h2 id="安装解释EDK"><a href="#安装解释EDK" class="headerlink" title="安装解释EDK"></a>安装解释EDK</h2><p>EDK也就是EFI Development Kit，类似JDK一样，EDK将会是开发efi文件的库，我们在ubuntu下操作，安装EDK2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/tianocore/edk2.git<br></code></pre></td></tr></table></figure><p>一些依赖库文件的下载指令放在下面，当然是ubuntu的apt，如果你是debian就改成yum</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install build-essential uuid-dev iasl git gcc-5 nasm python3-distutils<br></code></pre></td></tr></table></figure><p>文件指针切入edk2目录下，导入一些子项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git submodule update --init<br></code></pre></td></tr></table></figure><p>安装完成会出现一大堆文件，这些文件夹的共性就是都以<code>Pkg</code>结尾，其中关注两个文件夹<code>MdePkg</code>和<code>BaseTools</code>，前者是库而后者就是工具，因为我们要自己写Efi，所以我们新建一个文件夹，就叫<code>MinPkg</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@minloha:~/LearnEFI/code/edk2# ls<br>ArmPkg           CryptoPkg         FatPkg               Maintainers.txt  pip-requirements.txt  SourceLevelDebugPkg<br>ArmPlatformPkg   DynamicTablesPkg  FmpDevicePkg         MdeModulePkg     ReadMe.rst            StandaloneMmPkg<br>ArmVirtPkg       edksetup.bat      IntelFsp2Pkg         MdePkg           RedfishPkg            UefiCpuPkg<br>BaseTools        edksetup.sh       IntelFsp2WrapperPkg  NetworkPkg       SecurityPkg           UefiPayloadPkg<br>Conf             EmbeddedPkg       License-History.txt  OvmfPkg          ShellPkg              UnitTestFrameworkPkg<br>CONTRIBUTING.md  EmulatorPkg       License.txt          PcAtChipsetPkg   SignedCapsulePkg<br>root@minloha:~/LearnEFI/code/edk2# mkdir MinPkg<br>root@minloha:~/LearnEFI/code/edk2#<br></code></pre></td></tr></table></figure><p>强调两个文件类型<code>.dsc</code>和<code>.dec</code>，前者是对当前Pkg的描述后者是用于声明公开接口的描述。找到最经典的<code>Hello world</code>代码存放位置，里面保存了<code>.inf</code>和源码<code>.c</code>文件，这里注意，因为是底层所以没有标准库，也就意味着所有的输出函数和变量定义都必须重新写，也就是无法再像以往写代码一样去定义变量了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@minloha:~/LearnEFI/code# cd edk2/MdeModulePkg/Application/HelloWorld<br>root@minloha:~/LearnEFI/code/edk2/MdeModulePkg/Application/HelloWorld# ls<br>HelloWorld.c  HelloWorldExtra.uni  HelloWorld.inf  HelloWorldStr.uni  HelloWorld.uni<br>root@minloha:~/LearnEFI/code/edk2/MdeModulePkg/Application/HelloWorld#<br></code></pre></td></tr></table></figure><p>打开<code>.inf</code>进行解释，内容如下，<code>[Defines]</code>定义了程序的版本、程序名、引导UID、版本以及程序入口，<code>[Sources]</code>写出了程序所需要的资源文件，即源码和配置。<code>[Packages]</code>定义了所需要EDK的包，<code>[LibraryClasses]</code>列举了使用的接口，<code>[Pcd]</code>规定了一些常量字符串，引用了<code>.dec</code>文件中所写的内容 </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">## @file</span><br><span class="hljs-comment">#  Sample UEFI Application Reference EDKII Module.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  This is a sample shell application that will print &quot;UEFI Hello World!&quot; to the</span><br><span class="hljs-comment">#  UEFI Console based on PCD setting.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  It demos how to use EDKII PCD mechanism to make code more flexible.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  Copyright (c) 2008 - 2018, Intel Corporation. All rights reserved.&lt;BR&gt;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  SPDX-License-Identifier: BSD-2-Clause-Patent</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">##</span><br><br><span class="hljs-section">[Defines]</span><br>  <span class="hljs-attr">INF_VERSION</span>                    = <span class="hljs-number">0</span>x00010005<br>  <span class="hljs-attr">BASE_NAME</span>                      = HelloWorld<br>  <span class="hljs-attr">MODULE_UNI_FILE</span>                = HelloWorld.uni<br>  <span class="hljs-attr">FILE_GUID</span>                      = <span class="hljs-number">6987936</span>E-ED34-<span class="hljs-number">44</span>db-AE97-<span class="hljs-number">1</span>FA5E4ED2116<br>  <span class="hljs-attr">MODULE_TYPE</span>                    = UEFI_APPLICATION<br>  <span class="hljs-attr">VERSION_STRING</span>                 = <span class="hljs-number">1.0</span><br>  <span class="hljs-attr">ENTRY_POINT</span>                    = UefiMain<br><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  This flag specifies whether HII resource section is generated into PE image.</span><br><span class="hljs-comment">#</span><br>  <span class="hljs-attr">UEFI_HII_RESOURCE_SECTION</span>      = <span class="hljs-literal">TRUE</span><br><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The following information is for reference only and not required by the build tools.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  VALID_ARCHITECTURES           = IA32 X64 EBC</span><br><span class="hljs-comment">#</span><br><span class="hljs-section">[Sources]</span><br>  HelloWorld.c<br>  HelloWorldStr.uni<br><br><span class="hljs-section">[Packages]</span><br>  MdePkg/MdePkg.dec<br>  MdeModulePkg/MdeModulePkg.dec<br><br><span class="hljs-section">[LibraryClasses]</span><br>  UefiApplicationEntryPoint<br>  UefiLib<br>  PcdLib<br><br><span class="hljs-section">[FeaturePcd]</span><br>  gEfiMdeModulePkgTokenSpaceGuid.PcdHelloWorldPrintEnable   ## CONSUMES<br><br><span class="hljs-section">[Pcd]</span><br>  gEfiMdeModulePkgTokenSpaceGuid.PcdHelloWorldPrintString   ## SOMETIMES_CONSUMES<br>  gEfiMdeModulePkgTokenSpaceGuid.PcdHelloWorldPrintTimes    ## SOMETIMES_CONSUMES<br><br><span class="hljs-section">[UserExtensions.TianoCore.&quot;ExtraFiles&quot;]</span><br>  HelloWorldExtra.uni<br></code></pre></td></tr></table></figure><p>EDK的编译是通过make进行的，我们需要切换到EDK2的目录下的<code>Conf</code>文件夹修改target.txt来改变编译输出。</p><h2 id="C的指针很强大"><a href="#C的指针很强大" class="headerlink" title="C的指针很强大"></a>C的指针很强大</h2><p>指针是C语言的核心，在深入EFI底层前，必须要先复习一下C指针的含义，随便写两句代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdio.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> age = <span class="hljs-number">20</span>;<br>        <span class="hljs-keyword">int</span> *p_age = &amp;age;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;age=%d,address=%p\n&quot;</span>,age,&amp;age);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p_age=%d,address=%p,paddress=%p\n&quot;</span>,*p_age,p_age,&amp;p_age);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用gcc编译并运行，可以看到age与p_age的内存地址address是一个，但是paddress却和address不同</p><p>p_age作为指向age内存的指针，内部必然存储了age变量的内存地址，对p_age变量而言，输出的address就是保存age的内存地址，而paddress输出的是指针在内存的位置，通俗的说就是一个是复制别人的，一个是自己保存的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@minloha:~/LearnEFI/C/pointer# gcc main.c<br>root@minloha:~/LearnEFI/C/pointer# ./a.out<br>age=20,address=0x7ffee75e2bac<br>p_age=20,address=0x7ffee75e2bac,paddress=0x7ffee75e2bb0<br>root@minloha:~/LearnEFI/C/pointer#<br></code></pre></td></tr></table></figure><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/efi/pointer.png" alt="pointer"></p><p>指针就是保存地址的变量，地址就是一个可以被指的指针。在底层操作中，直接操作变量是无意义的，因为无法从根本上修改变量内容，所以利用指针进行操作内存，直接修改数据是非常高效的。</p><h2 id="编译出EFI"><a href="#编译出EFI" class="headerlink" title="编译出EFI"></a>编译出EFI</h2><p>在EDK2目录中使用指令，可以编译出<code>.efi</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -C BaseTools<br></code></pre></td></tr></table></figure><p>第一次编译会出现问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">make[2]: Leaving directory &#x27;/root/LearnEFI/code/edk2/BaseTools/Source/C/DevicePath&#x27;<br>Finished building BaseTools C Tools with HOST_ARCH=X64<br>make[1]: Leaving directory &#x27;/root/LearnEFI/code/edk2/BaseTools/Source/C&#x27;<br>make -C Source/Python<br>make[1]: Entering directory &#x27;/root/LearnEFI/code/edk2/BaseTools/Source/Python&#x27;<br>make[1]: Nothing to be done for &#x27;all&#x27;.<br>make[1]: Leaving directory &#x27;/root/LearnEFI/code/edk2/BaseTools/Source/Python&#x27;<br>make -C Tests<br>make[1]: Entering directory &#x27;/root/LearnEFI/code/edk2/BaseTools/Tests&#x27;<br>/bin/sh: 1: python: not found<br>make[1]: *** [GNUmakefile:11: test] Error 127<br>make[1]: Leaving directory &#x27;/root/LearnEFI/code/edk2/BaseTools/Tests&#x27;<br>make: *** [GNUmakefile:19: Tests] Error 2<br>make: Leaving directory &#x27;/root/LearnEFI/code/edk2/BaseTools&#x27;<br>root@minloha:~/LearnEFI/code/edk2#<br></code></pre></td></tr></table></figure><p>没错，<code>python: not found</code>，原因是python版本问题，解决方法就是先找到python位置，然后就要把python3.8与python连接在一起。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@minloha:~/LearnEFI/code/edk2# whereis python<br>python: /usr/bin/python3.8-config /usr/bin/python3.8 /usr/bin/python2.7 /usr/lib/python3.8 /usr/lib/python2.7 /usr/lib/python3.9 /etc/python3.8 /etc/python2.7 /usr/local/lib/python3.8 /usr/local/lib/python2.7 /usr/include/python3.8<br>root@minloha:~/LearnEFI/code/edk2# sudo ln -s /usr/bin/python3.8 /usr/bin/python<br>root@minloha:~/LearnEFI/code/edk2# python --version<br>Python 3.8.10<br>root@minloha:~/LearnEFI/code/edk2#<br></code></pre></td></tr></table></figure><p>然后重新make一下就可以了。为了运行<code>.efi</code>我们要一个软件<code>qemu</code>，安装一下吧。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在了解这么多关于EFI的知识和C语言的操作后，相信你一定可以写出一个自己的EFI系统了，年三十晚的一篇文字</p><blockquote><p>新年快乐哟！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建属于自己的Git仓库</title>
    <link href="/2022/01/27/%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84Git%E4%BB%93%E5%BA%93/"/>
    <url>/2022/01/27/%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84Git%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="面向过程的说说吧"><a href="#面向过程的说说吧" class="headerlink" title="面向过程的说说吧"></a>面向过程的说说吧</h2><p>所谓工欲善其事必先利其器，服务器上首先要先安装<code>Git</code>才可以部署Git服务端，我的服务器是Ubuntu系统，所以我就用ubuntu说事</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install git<br></code></pre></td></tr></table></figure><p>安装完成后检查一下git的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@minloha:~# git --version<br>git version 2.25.1<br>root@minloha:~#<br></code></pre></td></tr></table></figure><p>首先我们要创建公共用户<code>git</code>并输入密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@minloha:~# id git<br>id: ‘git’: no such user<br>root@minloha:~# adduser git<br>Adding user `git&#x27; ...<br>Adding new group `git&#x27; (1000) ...<br>Adding new user `git&#x27; (1000) with group `git&#x27; ...<br>Creating home directory `/home/git&#x27; ...<br>Copying files from `/etc/skel&#x27; ...<br>New password:<br>Retype new password:<br>passwd: password updated successfully<br>Changing the user information for git<br>Enter the new value, or press ENTER for the default<br>        Full Name []: iMinloha<br>        Room Number []:<br>        Work Phone []:<br>        Home Phone []:<br>        Other []:<br>Is the information correct? [Y/n]<br>root@minloha:~#<br></code></pre></td></tr></table></figure><p>然后我们随便新建一个文件夹作为我们的git存放的地方</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@minloha:~/home# cd git<br>root@minloha:~/home/git# git init --bare MinProject.git<br>Initialized empty Git repository in /root/git/MinProject.git/<br>root@minloha:~/home/git# ls<br>MinProject.git<br>root@minloha:/home/git# chown -R git:git MinProject.git<br>chown: invalid user: ‘git:git’<br>root@minloha:/home/git#<br></code></pre></td></tr></table></figure><p>然后仓库就创建好了，对你没看错，创建好了，接着就是那客户端去生成一下咯，我们就把Cmake的代码同步一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 先克隆服务端的git，记得修改ip</span><br>C:\Users\Minloha\Desktop\demo&gt;git clone git@你的IP:/home/git/MinProject.git<br>Cloning into &#x27;MinProject&#x27;...<br>The authenticity of host &#x27;XXX.XXX.XXX.XXX (XXX.XXX.XXX.XXX)&#x27; can&#x27;t be established.<br>ECDSA key fingerprint is SHA256:wZ1TgMK+m4PnfJkXKeUSTRLqmkaPeXVMXye1ijRkZK0.<br>Are you sure you want to continue connecting (yes/no/[fingerprint])? yes<br>Warning: Permanently added &#x27;XXX.XXX.XXX.XXX&#x27; (ECDSA) to the list of known hosts.<br>git@XXX.XXX.XXX.XXX&#x27;s password:<br>warning: You appear to have cloned an empty repository.<br><br><span class="hljs-meta">#</span><span class="bash"> 切换文件指针</span><br>C:\Users\Minloha\Desktop\demo&gt;cd MinProject<br><span class="hljs-meta">#</span><span class="bash"> 把文件夹所有内容加入git</span><br>C:\Users\Minloha\Desktop\demo&gt;git add .<br><span class="hljs-meta">#</span><span class="bash"> 设置git同步目标</span><br>C:\Users\Minloha\Desktop\demo&gt;git commit -m &#x27;CMake代码&#x27;<br>...............................<br><span class="hljs-meta">#</span><span class="bash"> 推送代码</span><br>C:\Users\Minloha\Desktop\myGit\MinProject&gt;git push -u origin master<br>Enumerating objects: 122, done.<br>Counting objects: 100% (122/122), done.<br>Delta compression using up to 8 threads<br>Compressing objects: 100% (116/116), done.<br>Writing objects: 100% (122/122), 52.85 KiB | 1.06 MiB/s, done.<br>Total 122 (delta 57), reused 0 (delta 0), pack-reused 0<br>remote: Resolving deltas: 100% (57/57), done.<br>To XXX.XXX.XXX.XXX:/home/git/MinProject.git<br> * [new branch]      master -&gt; master<br><br>C:\Users\Minloha\Desktop\myGit\MinProject&gt;<br></code></pre></td></tr></table></figure><p>然后你就已经把代码克隆到服务器上了</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录一下CMAKE的笔记</title>
    <link href="/2022/01/26/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8BCMAKE%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/01/26/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8BCMAKE%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍CMAKE"><a href="#介绍CMAKE" class="headerlink" title="介绍CMAKE"></a>介绍CMAKE</h2><p>CMAKE是一款跨平台的编译工具，区别与Linux的make系统，CMAKE的功能更丰富，可以将C/C++/java构建成相应的make文件以便于安装使用，同时一些好用的工具也都是使用Make进行安装的，效果不错推荐学习</p><h2 id="从一个CPP说起"><a href="#从一个CPP说起" class="headerlink" title="从一个CPP说起"></a>从一个CPP说起</h2><p>首先打开咱的开发环境，新建一个CPP文件，写一些比较<code>基础</code>的代码，用20级泰勒展开计算e的大小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 利用泰勒展开计算自然常数e的大小</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//计算阶乘</span><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> rtnNumber = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= number;i++) &#123;<br>        rtnNumber *= i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> rtnNumber;<br>&#125;<br><span class="hljs-comment">//计算任意指数幂</span><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span> <span class="hljs-title">power</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> level)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span> m = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>; t &lt; level;t++) &#123;<br>        m *= x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m;<br>&#125;<br><span class="hljs-comment">//表达出泰勒公式进行</span><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getE</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> level)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span> num = <span class="hljs-number">1.0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= level;j++) &#123;<br>        cout &lt;&lt; (<span class="hljs-built_in">power</span>(x, j)) / <span class="hljs-built_in">factorial</span>(j) &lt;&lt; endl;<br>        num = num + (<span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span>)(<span class="hljs-built_in">power</span>(x, j)) / <span class="hljs-built_in">factorial</span>(j);<br>    &#125;<br>    <span class="hljs-keyword">return</span> num;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//输出结果，即getE(1,展开级数)</span><br>    cout &lt;&lt; <span class="hljs-built_in">getE</span>(<span class="hljs-number">1</span>,<span class="hljs-number">20</span>) &lt;&lt;endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="将CPP编译为makefile"><a href="#将CPP编译为makefile" class="headerlink" title="将CPP编译为makefile"></a>将CPP编译为makefile</h2><h3 id="内部构建"><a href="#内部构建" class="headerlink" title="内部构建"></a>内部构建</h3><p>在编译为make文件之前先用<code>g++</code>编译输出一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@minloha:~/LearnCmake/demo01# g++ hello.cpp<br>root@minloha:~/LearnCmake/demo01# ./a.out<br>2.71828<br>root@minloha:~/LearnCmake/demo01#<br></code></pre></td></tr></table></figure><p>可以看到输出是正常的，然后就可以去编写CMake的配置文件<code>CMakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 所有指令不区分大小写,变量区分大小写。为了便于区分,建议所有指令都大写</span><br><span class="hljs-keyword">PROJECT</span> (hello)<br><span class="hljs-comment"># 设置CMake变量SRC_LIST,并赋值为hello.cpp,多个文件一一列举就好</span><br><span class="hljs-keyword">SET</span>(SRC_LIST hello.cpp)<br><span class="hljs-comment"># 输出CMake编译自定义的输出信息</span><br><span class="hljs-keyword">MESSAGE</span>(STATUS <span class="hljs-string">&quot;This is BINARY dir&quot;</span> <span class="hljs-variable">$&#123;HELLO_BINARY_DIR&#125;</span>)<br><span class="hljs-keyword">MESSAGE</span>(STATUS <span class="hljs-string">&quot;This is SOURCE dir&quot;</span> <span class="hljs-variable">$&#123;HELLO_SOURCE_DIR&#125;</span>)<br><span class="hljs-comment"># 生成可执行文件hello</span><br><span class="hljs-keyword">ADD_EXECUTABLE</span>(hello <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure><p>然后就可以使用CMake指令去生成文件<code>cmake .</code>指令末尾有一个点号，表示当前文件夹下的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@minloha:~/LearnCmake/demo01# cmake .<br>-- This is BINARY dir<br>-- This is SOURCE dir<br>-- Configuring done<br>-- Generating done<br>-- Build files have been written to: /root/LearnCmake/demo01<br>root@minloha:~/LearnCmake/demo01# ls<br>a.out  CMakeCache.txt  CMakeFiles  cmake_install.cmake  CMakeLists.txt  hello  hello.cpp  Makefile<br>root@minloha:~/LearnCmake/demo01#<br></code></pre></td></tr></table></figure><p>然后就可以用make指令编译，bash进行执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@minloha:~/LearnCmake/demo01# make<br>Scanning dependencies of target hello<br>[ 50%] Building CXX object CMakeFiles/hello.dir/hello.cpp.o<br><span class="hljs-meta">[100%</span><span class="bash">] Linking CXX executable hello</span><br><span class="hljs-meta">[100%</span><span class="bash">] Built target hello</span><br>root@minloha:~/LearnCmake/demo01# ./hello<br>2.71828<br>root@minloha:~/LearnCmake/demo01#<br></code></pre></td></tr></table></figure><h3 id="外部构建"><a href="#外部构建" class="headerlink" title="外部构建"></a>外部构建</h3><p>在cpp同级目录新建一个文件夹，把命令行<code>cd</code>进去，然后使用<code>cmake ..</code>进行生成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@minloha:~/LearnCmake/demo02# mkdir build<br>root@minloha:~/LearnCmake/demo02# cd build/<br>root@minloha:~/LearnCmake/demo02/build# cmake ..<br>-- The C compiler identification is GNU 9.4.0<br>-- The CXX compiler identification is GNU 9.4.0<br>-- Check for working C compiler: /usr/bin/cc<br>-- Check for working C compiler: /usr/bin/cc -- works<br>-- Detecting C compiler ABI info<br>-- Detecting C compiler ABI info - done<br>-- Detecting C compile features<br>-- Detecting C compile features - done<br>-- Check for working CXX compiler: /usr/bin/c++<br>-- Check for working CXX compiler: /usr/bin/c++ -- works<br>-- Detecting CXX compiler ABI info<br>-- Detecting CXX compiler ABI info - done<br>-- Detecting CXX compile features<br>-- Detecting CXX compile features - done<br>-- This is BINARY dir<br>-- This is SOURCE dir<br>-- Configuring done<br>-- Generating done<br>-- Build files have been written to: /root/LearnCmake/demo02/build<br>root@minloha:~/LearnCmake/demo02/build# ls<br>CMakeCache.txt  CMakeFiles  cmake_install.cmake  Makefile<br>root@minloha:~/LearnCmake/demo02/build#<br></code></pre></td></tr></table></figure><p>然后就可以打包发给你的小伙伴了</p><h2 id="提高项目格局"><a href="#提高项目格局" class="headerlink" title="提高项目格局"></a>提高项目格局</h2><p>为了让项目被别人看到后认为这是大佬，我们要专门新建一个文件夹<code>(src)</code>用于存放代码，同时注意，src文件夹下也要写一份CMakeLists.txt，目录结构是这样的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@minloha:~/LearnCmake/demo03# tree<br>.<br>├── build<br>├── CMakeLists.txt<br>└── src<br>    ├── CMakeLists.txt<br>    └── hello.cpp<br><br>2 directories, 3 files<br>root@minloha:~/LearnCmake/demo03#<br></code></pre></td></tr></table></figure><p>在根目录下的<code>CMakeLists.txt</code>写如下面内容</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># PROJECT(项目名)</span><br><span class="hljs-keyword">PROJECT</span>(YEAH)<br><span class="hljs-comment"># 添加源文件目录与生成make文件包含文件夹</span><br><span class="hljs-keyword">ADD_SUBDIRECTORY</span>(src bin)<br></code></pre></td></tr></table></figure><p>在内层文件下<code>src\CMakeLists.txt</code>写入下面内容</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># ADD_EXECUTABLE(可执行文件名 cpp代码)</span><br><span class="hljs-keyword">ADD_EXECUTABLE</span>(YEAH main.cpp)<br></code></pre></td></tr></table></figure><p>然后我们移到build目录下面使用构建指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@minloha:~/LearnCmake/demo02/build# cmake ..<br>-- The C compiler identification is GNU 9.4.0<br>-- The CXX compiler identification is GNU 9.4.0<br>-- Check for working C compiler: /usr/bin/cc<br>-- Check for working C compiler: /usr/bin/cc -- works<br>-- Detecting C compiler ABI info<br>-- Detecting C compiler ABI info - done<br>-- Detecting C compile features<br>-- Detecting C compile features - done<br>-- Check for working CXX compiler: /usr/bin/c++<br>-- Check for working CXX compiler: /usr/bin/c++ -- works<br>-- Detecting CXX compiler ABI info<br>-- Detecting CXX compiler ABI info - done<br>-- Detecting CXX compile features<br>-- Detecting CXX compile features - done<br>CMake Warning (dev) in CMakeLists.txt:<br>  No cmake_minimum_required command is present.  A line of code such as<br><br>    cmake_minimum_required(VERSION 3.16)<br><br>  should be added at the top of the file.  The version specified may be lower<br>  if you wish to support older CMake versions for this project.  For more<br>  information run &quot;cmake --help-policy CMP0000&quot;.<br>This warning is for project developers.  Use -Wno-dev to suppress it.<br><br>-- Configuring done<br>-- Generating done<br>-- Build files have been written to: /root/LearnCmake/demo02/build<br>root@minloha:~/LearnCmake/demo02/build# ls<br>bin  CMakeCache.txt  CMakeFiles  cmake_install.cmake  Makefile<br>root@minloha:~/LearnCmake/demo02/build#<br></code></pre></td></tr></table></figure><p>注意出现报错，这是因为在src目录下的CMakeLists.txt文件，我们只写入了一行，而这并不被新版本的CMake认同，不过不影响编译输出。然后我们就make一下就可以找到生成的文件夹<code>bin</code>了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@minloha:~/LearnCmake/demo02/build# make<br>Scanning dependencies of target YEAH<br>[ 50%] Building CXX object bin/CMakeFiles/YEAH.dir/main.o<br><span class="hljs-meta">[100%</span><span class="bash">] Linking CXX executable YEAH</span><br><span class="hljs-meta">[100%</span><span class="bash">] Built target YEAH</span><br>root@minloha:~/LearnCmake/demo02/build# ls<br>bin  CMakeCache.txt  CMakeFiles  cmake_install.cmake  Makefile<br>root@minloha:~/LearnCmake/demo02/build# cd bin/<br>root@minloha:~/LearnCmake/demo02/build/bin# ls<br>CMakeFiles  cmake_install.cmake  Makefile  YEAH<br>root@minloha:~/LearnCmake/demo02/build/bin#<br></code></pre></td></tr></table></figure><h2 id="把项目刻进硬盘里"><a href="#把项目刻进硬盘里" class="headerlink" title="把项目刻进硬盘里"></a>把项目刻进硬盘里</h2><p>这一步就是要讲CMake生成可以进行<code>make install</code>指令的文件，在这之前先开辟新的文件结构，按照下表所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@minloha:~/LearnCmake/demo03# tree<br>.<br>├── build<br>├── CMakeLists.txt<br>├── COPYRIGHT<br>├── doc<br>│   └── YEAH.txt<br>├── runYEAH.sh<br>└── src<br>    ├── CMakeLists.txt<br>    └── main.cpp<br><br>3 directories, 6 files<br>root@minloha:~/LearnCmake/demo03#<br></code></pre></td></tr></table></figure><p>把根下的<code>CMakeLists.txt</code>内容修改为这样</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span>(YEAH)<br><span class="hljs-keyword">ADD_SUBDIRECTORY</span>(src bin)<br><span class="hljs-comment"># 同上</span><br><span class="hljs-comment"># ---------------</span><br><span class="hljs-comment"># 安装绝对文件要指定安装路径，share/doc/cmake为安装路径,可以使用绝对路径</span><br><span class="hljs-comment"># 如果是相对路径则默认是新建变量：CMAKE_INSTALL_PREFIX，按照其内部存储进行安装,默认值/usr/local</span><br><span class="hljs-keyword">INSTALL</span>(FILES COPYRIGHT DESTINATION share/doc/cmake)<br><br><span class="hljs-comment"># 安装指定运行脚本,在这里是runYEAH.sh，文件安装到/usr/local/bin目录</span><br><span class="hljs-keyword">INSTALL</span>(PROGRAMS runYEAH.sh DESTINATION bin)<br><br><span class="hljs-comment"># 指定文件的安装目录,也就是根文件的doc目录安装到share/doc/cmake，切记doc可以把文件夹一起安装,而doc/只会把内部的文件安装</span><br><span class="hljs-keyword">INSTALL</span>(DIRECTORY doc/ DESTINATION share/doc/cmake)<br></code></pre></td></tr></table></figure><p>其他文件的具体内容可以自行修改了,比如runYEAH.sh或者COPYRIGHT，YEAH.txt，总之不是CAMakeLists.txt都可以动，然后就切换到build目录下进行cmake</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@minloha:~/LearnCmake/demo03/build# cmake ..<br>-- The C compiler identification is GNU 9.4.0<br>-- The CXX compiler identification is GNU 9.4.0<br>-- Check for working C compiler: /usr/bin/cc<br>-- Check for working C compiler: /usr/bin/cc -- works<br>-- Detecting C compiler ABI info<br>-- Detecting C compiler ABI info - done<br>-- Detecting C compile features<br>-- Detecting C compile features - done<br>-- Check for working CXX compiler: /usr/bin/c++<br>-- Check for working CXX compiler: /usr/bin/c++ -- works<br>-- Detecting CXX compiler ABI info<br>-- Detecting CXX compiler ABI info - done<br>-- Detecting CXX compile features<br>-- Detecting CXX compile features - done<br>CMake Warning (dev) in CMakeLists.txt:<br>  No cmake_minimum_required command is present.  A line of code such as<br><br>    cmake_minimum_required(VERSION 3.16)<br><br>  should be added at the top of the file.  The version specified may be lower<br>  if you wish to support older CMake versions for this project.  For more<br>  information run &quot;cmake --help-policy CMP0000&quot;.<br>This warning is for project developers.  Use -Wno-dev to suppress it.<br><br>-- Configuring done<br>-- Generating done<br>-- Build files have been written to: /root/LearnCmake/demo03/build<br></code></pre></td></tr></table></figure><p>然后就可以make构建然后make安装了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@minloha:~/LearnCmake/demo03/build# make<br>Scanning dependencies of target YEAH<br>[ 50%] Building CXX object bin/CMakeFiles/YEAH.dir/main.o<br><span class="hljs-meta">[100%</span><span class="bash">] Linking CXX executable YEAH</span><br><span class="hljs-meta">[100%</span><span class="bash">] Built target YEAH</span><br>lroot@minloha:~/LearnCmake/demo03/build# ls<br>bin  CMakeCache.txt  CMakeFiles  cmake_install.cmake  Makefile<br>root@minloha:~/LearnCmake/demo03/build# cd bin<br>root@minloha:~/LearnCmake/demo03/build/bin# ls<br>CMakeFiles  cmake_install.cmake  Makefile  YEAH<br>root@minloha:~/LearnCmake/demo03/build/bin# make install<br><span class="hljs-meta">[100%</span><span class="bash">] Built target YEAH</span><br>Install the project...<br>-- Install configuration: &quot;&quot;<br>root@minloha:~/LearnCmake/demo03/build/bin#<br></code></pre></td></tr></table></figure><h2 id="共享库的构建"><a href="#共享库的构建" class="headerlink" title="共享库的构建"></a>共享库的构建</h2><p>将上一次的make文件复制一份继续写，项目结构是这样的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@minloha:~/LearnCmake/demo04# tree<br>.<br>├── build<br>├── CMakeLists.txt<br>├── COPYRIGHT<br>├── doc<br>│   └── YEAH.txt<br>├── lib<br>│   ├── CMakeLists.txt<br>│   ├── main.cpp<br>│   └── main.h<br>└── runYEAH.sh<br><br>3 directories, 7 files<br>root@minloha:~/LearnCmake/demo04#<br></code></pre></td></tr></table></figure><p>所谓动态库就是windows中常见的.dll动态链接库，静态库就是.lib文件，首先我们先要有一个.h头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _MAIN_H_</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _MAIN_H_</span><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span> <span class="hljs-title">power</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> level)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getE</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> level)</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>讲头文件包含进cpp文件内，也就是使用下面的语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;main.h&quot;</span></span><br></code></pre></td></tr></table></figure><p>在lib下的CMakeLists.txt写入下面内容</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 定义一个LIBYEAH_SRC变量，保存数据是main.cpp</span><br><span class="hljs-keyword">SET</span>(LIBYEAH_SRC main.cpp)<br><span class="hljs-comment"># SHARED是生成共享库，STATIC是生成静态库</span><br><span class="hljs-keyword">ADD_LIBRARY</span>(YEAH SHARED <span class="hljs-variable">$&#123;LIBYEAH_SRC&#125;</span>)<br></code></pre></td></tr></table></figure><p>然后就可以生成试试了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@minloha:~/LearnCmake/demo04/build# cmake ..<br>-- The C compiler identification is GNU 9.4.0<br>-- The CXX compiler identification is GNU 9.4.0<br>-- Check for working C compiler: /usr/bin/cc<br>-- Check for working C compiler: /usr/bin/cc -- works<br>-- Detecting C compiler ABI info<br>-- Detecting C compiler ABI info - done<br>-- Detecting C compile features<br>-- Detecting C compile features - done<br>-- Check for working CXX compiler: /usr/bin/c++<br>-- Check for working CXX compiler: /usr/bin/c++ -- works<br>-- Detecting CXX compiler ABI info<br>-- Detecting CXX compiler ABI info - done<br>-- Detecting CXX compile features<br>-- Detecting CXX compile features - done<br>CMake Warning (dev) in CMakeLists.txt:<br>  No cmake_minimum_required command is present.  A line of code such as<br><br>    cmake_minimum_required(VERSION 3.16)<br><br>  should be added at the top of the file.  The version specified may be lower<br>  if you wish to support older CMake versions for this project.  For more<br>  information run &quot;cmake --help-policy CMP0000&quot;.<br>This warning is for project developers.  Use -Wno-dev to suppress it.<br><br>-- Configuring done<br>-- Generating done<br>-- Build files have been written to: /root/LearnCmake/demo04/build<br>root@minloha:~/LearnCmake/demo04/build# make<br>Scanning dependencies of target YEAH<br>[ 50%] Building CXX object bin/CMakeFiles/YEAH.dir/main.o<br><span class="hljs-meta">[100%</span><span class="bash">] Linking CXX shared library libYEAH.so</span><br><span class="hljs-meta">[100%</span><span class="bash">] Built target YEAH</span><br>root@minloha:~/LearnCmake/demo04/build# cd bin/<br>root@minloha:~/LearnCmake/demo04/build/bin# ls<br>CMakeFiles  cmake_install.cmake  libYEAH.so  Makefile<br>root@minloha:~/LearnCmake/demo04/build/bin#<br></code></pre></td></tr></table></figure><p>可以看到生成了linYEAH.so的动态库</p><h2 id="指令总结与补充"><a href="#指令总结与补充" class="headerlink" title="指令总结与补充"></a>指令总结与补充</h2><div class="table-container"><table><thead><tr><th>指令</th><th>功能</th></tr></thead><tbody><tr><td>PROJECT (项目名)</td><td>定义项目</td></tr><tr><td>SET(变量名 值)</td><td>定义一个Make变量保存数据</td></tr><tr><td>MESSAGE(STATUS 字符串)</td><td>使用make时输出一些信息或警告</td></tr><tr><td>ADD_EXECUTABLE(生成文件名 源文件)</td><td>添加CMAKE时生成的可执行文件</td></tr><tr><td>ADD_SUBDIRECTORY( 当前目录 生成的目录)</td><td>将已有的目录作为Make生成的子目录</td></tr><tr><td>INSTALL(类型 文件 DESTINATION 目标文件夹)</td><td>将不同类型的文件生成到不同的文件夹中，类型可以参考上文</td></tr><tr><td>ADD_LIBRARY(库名 静态/动态 源文件)</td><td>将源文件生成为动态或静态库</td></tr></tbody></table></div><p>全篇的运行Cmake都有警告，解决办法是在CMakeLists.txt中加入<code>cmake_minimum_required( VERSION 2.8 )</code>，降低Cmake语言版本即可</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>圆锥曲线必杀技:仿射几何</title>
    <link href="/2022/01/02/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF%E5%A4%A7%E9%A2%98/"/>
    <url>/2022/01/02/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF%E5%A4%A7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><blockquote><p>这页使用了大量数学符号，加载可能会慢，耐心等待</p></blockquote><p>圆锥曲线大题一直都是以难为名，不少学子在第二问面前束手无策，而只有少部分人尝试到韦达定理，最终收获8分而去。但是，对于这类问题还有一种解法，那就是使用仿射几何解题，其实在函数章节我们就以及对仿射这一概念略微有所了解，也就是伸缩变换。仿射几何解题的精髓和伸缩变化类似，在伸缩过程中，把椭圆转化为圆处理，这样可以找出新的特殊关系，从而解题</p><blockquote><p>仿射几何隶属高等数学，并非高中必修，所以千万不要把仿射几何的结论直接使用</p></blockquote><p>在使用仿射变换之前需要记得几个性质</p><ol><li>同素性：在经过变换之后，点仍然是点，线仍然是线</li><li>结合性：在经过变换之后，在直线上的点仍然在直线上</li><li>一般位置关系(相交、相切、相离)不变</li></ol><p>那么怎么使用仿射变换解题呢？以一道十分有趣的题为例子(一轮练习册)</p><h2 id="抛物线的仿射变换"><a href="#抛物线的仿射变换" class="headerlink" title="抛物线的仿射变换"></a>抛物线的仿射变换</h2><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/question/1.png" alt="本体"></p><h3 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h3><p>跳过，抛物线标准方程为$y^2$=4x，准线是x=-1</p><h3 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h3><p>[设点]：从A点开始，我们借用仿射变换的思想，将抛物线变成无参形式，及形如$y^2$=x的形式，所以可以设A点横坐标为t，纵坐标为4$t^2$，但是这样做等于没设，所以转化一下，将A点设为($t^2$,2t)，这样就可以了</p><p>[设直线]：因为直线AB过点F，可以通过<code>x=my+n</code>直线式设出直线方程，将F点坐标带入，而m为斜率的倒数，所以得到直线式$l_{AB}$的表达式</p><script type="math/tex; mode=display">l_{AB}:x=\frac{t^2-1}{2t}y+1</script><p>[联立]：根据一般的流程，接下来就要联立了，我们把$l_{AB}$带入抛物线标准式内得到二次方程</p><script type="math/tex; mode=display">y^2-\frac{2(t^2-1)}{t}y-4=0</script><p>根据韦达定理，我们得到AB两点纵坐标关系，即$y_Ay_B$=-4，而A点纵坐标又是我们设出来的，所以可以表示出B点纵坐标，$y_B=-\frac{2}{t}$，然后带回抛物线方程，得到t表达的B点坐标，B($\frac{1}{t^2}$,-$\frac{2}{t}$)</p><p>[用关系]：G点为三角形的中心，所以三个定点纵坐标的算术平均数，就是G点纵坐标，也就是0，所以得到C点纵坐标($\frac{2}{t}$-2t)，待会抛物线，得到横坐标，进而表达出C点坐标为($(\frac{1}{t}-t)^2$,$\frac{2}{t}$-2t)，然后根据这些数据关系，得到G点坐标</p><script type="math/tex; mode=display">G=(\frac{2t^4-2t^2+2}{3t^2},0)</script><p>[列关系]：利用三角形面积公式列出$S_1$和$S_2$然后求出比值表达式(巨型表达式警告)</p><script type="math/tex; mode=display">\frac{S_1}{S_2}=\frac{|\frac{2t^4-2t^2+2}{3t^2}-1|·|2t|}{|t^2-1-\frac{2t^4-2t^2+2}{3t^2}|·|\frac{2}{t}-2t|}（省略了同类型约去过程）</script><p>然后动用所有脑细胞化简表达式，得到一个相对简洁的式子</p><script type="math/tex; mode=display">\frac{S_1}{S_2}=2-\frac{t^2-2}{t^4-1}</script><p>[最简单的部分]：然后就是换元法，列出基本不等式了</p><p>令m=$t^2$-2&gt;0，面积的比值就可以表达为</p><script type="math/tex; mode=display">\frac{S_1}{S_2}=2-\frac{m}{m^2+4m+3}=2-\frac{1}{m+\frac{3}{m}+4}≥1+\frac{\sqrt{3}}{2}</script><p>当且仅当m=$\frac{3}{m}$时，也就是m=$\sqrt{3}$取得最小值</p><p>则$t^2$=$\sqrt{3}+2$，带入G点中，得到G点为(2,0)</p><hr><blockquote><p>象征结束的分割线</p></blockquote><p>这道题是2019浙江高考数学21题，运用了仿射变换的方法，将坐标全用一个字母设出，十分巧妙</p><h2 id="椭圆的仿射变化"><a href="#椭圆的仿射变化" class="headerlink" title="椭圆的仿射变化"></a>椭圆的仿射变化</h2><script type="math/tex; mode=display">已知椭圆C_1:\frac{x^2}{4}+y^2=1，过抛物线C_2:x^2=4y焦点F的直线交抛物线与M、N两点,\\连接NO与MO并与C_1交与A，B两点，连接AB，证明ΔOAB的面积S_{ΔOAB}为定值\\</script><p>先列出变换规则，自然的，可以利用矩阵解决</p><script type="math/tex; mode=display">\begin{cases}x'=\frac{x}{2}\\y'=y\\\end{cases}</script><script type="math/tex; mode=display">A=\left[\begin{matrix}\frac{1}{2}&&0\\0&&1\end{matrix} \right]</script><p>则对原坐标系进行仿射，即将XOY变为A(XOY)，x轴缩短为原来的一半，这样C~1~变换为$x’^2$+$y’^2$=1的圆，利用抛物线仿射知识(上一块)可以轻松证明变换后的 $k<em>{NO}k</em>{MO}$ 的乘积为-1，得到变化后的 OA⊥OB 这一性质，而正巧，A,B均为圆上的点可以得到 $S<em>{ΔOA’B’}=\frac{1}{2}r^2=\frac{1}{2}$ ，再反向利用变化规则，得到变化前的 $S</em>{ΔOAB}$=2$S_{ΔOA’B’}$=1 ，所以面积为定值</p><hr><p>在经历一番升华后，相信你对仿射变换一定有了一定的了解了吧，不过最后要说一点，就是考试时不要写出这是仿射变换或者利用仿射的性质，可以设设坐标，表示表示点，都可以。</p><blockquote><p>扩展知识，莫要提前专注研究</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新版本Kali的安装</title>
    <link href="/2021/12/27/%E5%85%A8%E6%96%B0%E7%89%88%E6%9C%ACKALI%E8%AF%95%E6%B0%B4/"/>
    <url>/2021/12/27/%E5%85%A8%E6%96%B0%E7%89%88%E6%9C%ACKALI%E8%AF%95%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍Kali"><a href="#介绍Kali" class="headerlink" title="介绍Kali"></a>介绍Kali</h1><p>Kali读作卡利，全名Kali Linux，是一款基于Debian的Linux操作系统，作为集成系统，内部包含了很多的渗透测试工具，并且从网络安全的角度分析，Kali是一个很好的工具系统，可以省去很多下载安装的麻烦步骤，同时也可以永久免费使用，而且最最重要的就是Kali内部安装了metasploit（十分好用的安全框架）</p><p>各大QQ群所谓的自称黑客，也都是因为会一点Kali的使用而存在优越感。集成工具集与散装软件自己配置其实没什么区别，无非是神化了，不过作为初学者，学习Kali还是很有用的（在此之前请保证你的英语与计算机水平足够），因为可以省去搜索的麻烦</p><h1 id="安装Kali"><a href="#安装Kali" class="headerlink" title="安装Kali"></a>安装Kali</h1><blockquote><p>安装不代表会使用，使用不代表懂原理能发散，所谓Kali学的好牢饭吃的早都是因人而异，只要保证是学习安全架构，就绝对不会有事（本人的观点）</p></blockquote><p> 一个KALI的镜像：<a href="https://mirrors.aliyun.com/kali-images">阿里镜像</a></p><p>一个虚拟机：<a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-16.2.1-18811642.exe">官网下载入口</a></p><p>首先需要配置一下虚拟机网络，因为我的KALI需要在与物理机同一个局域网下，所以我选择桥接网卡，然后就需要进入网络配置内修改一下桥接的网卡型号（因人而异，我的是无线网卡）</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/kali/1.png" alt="网络配置"></p><p>配置完网络就可以开启虚拟机了，因为是新下载的虚拟机，vm-tools还是要安装的</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/kali/2.png" alt="安装工具"></p><p>打开后需要选择第一个（带UI的下载界面）</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/kali/3.png" alt="选择安装方式"></p><p>然后就是选择你能接受的语言</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/kali/4.png" alt="语言"></p><p>然后配置输入法，文字语言等等，然后就慢慢等待即可</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/kali/5.png" alt="输入法"></p><blockquote><p>如果说2020是尝试，那2021绝对是完善</p></blockquote><p>桥接中可能会出现DHCP配置问题，请重新配置桥接网络</p><p>配置一下虚拟机的名字，随便设置</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/kali/6.png" alt="名字"></p><p>域名不是必填项，不过为了给自己打个广告还是写了</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/kali/7.png" alt="域名"></p><p>这里的非root用户就是今后使用KALI的root名，也是操作名，然后设置一下密码(ROOT密码)</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/kali/8.png" alt="根用户"></p><p>配置磁盘，如果不是尝试安装KALI到硬盘上，就默认</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/kali/9.png" alt="分区"></p><h2 id="切把分区改动写入"><a href="#切把分区改动写入" class="headerlink" title="切把分区改动写入"></a>切把分区改动写入</h2><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/kali/10.png" alt="保存改动"></p><p>然后只需要等待即可</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/kali/11.png" alt="安装系统"></p><p>在配置桌面环境时可以选择KDE、XFCE或GNOME桌面，下面是我个人觉得这些桌面环境的优缺点</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 个人观点</span><br><br>KDE：QT开发的Linux桌面，拥有绝对的美观，自定义性强，但是组件配置麻烦而且内存大（我选择KDE，因为UI养眼)<br><br>GNOME：简单易用插件多，绝大多数桌面Linux（比如ubuntu）默认的桌面系统，泛用性强，但自定义性差，管理麻烦<br><br>XFCE：占用内存小且比较稳，但是不是很美观，一般用于服务器的远程桌面中<br></code></pre></td></tr></table></figure><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/kali/12.png" alt="选择桌面"></p><p>接下来就等待KALI安装完成就行了(保证网络通畅耐心等待)</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/kali/13.png" alt="等待"></p><p>最后设置一下引导就可以享受KALI了！</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/kali/14.png" alt="引导项"></p><p>截一个KDE安装后的截图，不枉我等了半个小时（beautiful）</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/kali/15.png" alt="好耶"></p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/kali/16.png" alt="香香"></p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/kali/17.png" alt="不错"></p><p>末尾的要点提醒，记得弹出镜像文件，不然再次启动会打不开</p><h1 id="Kali的简单使用"><a href="#Kali的简单使用" class="headerlink" title="Kali的简单使用"></a>Kali的简单使用</h1><p>安装一下apache和mysql，配置一下Minloha早年开发的漏洞测试平台，做一些简单的渗透测试（下载地址:<a href="https://pan.minloha.cn/0:down/%E8%9C%9C%E6%B1%81%E6%BA%90%E7%A0%81/mvwa.zip）">https://pan.minloha.cn/0:down/%E8%9C%9C%E6%B1%81%E6%BA%90%E7%A0%81/mvwa.zip）</a></p><p> 当年写的比较匆忙，所以基本就是白板蓝字没有一点美化效果，很勉强的</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/kali/18.png" alt="mvwa"></p><p>因为现在的KALI使用的是MariaDB，而不允许php使用root用户，所以要新建一个用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">grant all privileges on *.* to 用户名@localhost identified by &#39;密码&#39;;<br></code></pre></td></tr></table></figure><p>所有信息填写如mvwa/config/config.php内容下，填写好后只需进入网页一次就完成所有步骤了</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/kali/19.png" alt="19"></p><p>然后简单试一下CSRF（跨站脚本攻击），可以看到还是好使的，index（数字）.php，数字代表了难度，数字越大难度越高，因为是半成品，所以可以自定义的哦~</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/kali/20.png" alt="放一下CSRF1的图片，依然能用"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>其实我从2019年后就没有兴趣玩KALI了，不过现在做网站维护与安全管理，非常迫切的需要一个集成环境，第一个想到的就是KALI，也顺便水一次博客，就这么做了。不过虚拟机安装现在应该都不需要教程了吧~</p><blockquote><p>这是2021年最后一篇装机文章了，2021年跨年不见不散哦~</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>装机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Socket通信</title>
    <link href="/2021/12/22/Socket%E9%80%9A%E4%BF%A1/"/>
    <url>/2021/12/22/Socket%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h1><p>先复习一下TCP/IP协议，网络分为物理层、数据连接层、网络层、传输层、会话层、表现层和应用层、TCP协议作用在传输层，表现的是三次握手，IP是网络层、HTTP是应用层。归纳一下TCP/IP协议是传输层协议，而Socket就是对TCP/IP的封装与使用。而HTTP就是发货站，包装数据。</p><p>Socket接口几乎是所有语言都拥有的API（Socket不是协议，是接口），初学者通过Socket可以实现对网络的初步利用与研究，可以实现局域网内简单的接受发送数据等等，这些都需要实现。</p><p>TCP协议是所有学习计算机的人必须知道的。</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/socket/TCP.jpg" alt="TCP通信"></p><p>在了解TCP协议后我们就可以使用Socket实现简单的消息服务器了，事不宜迟，现在就动手操作！</p><h1 id="开始编写"><a href="#开始编写" class="headerlink" title="开始编写"></a>开始编写</h1><p>再读懂这些代码之前保证你有<code>C++</code>,<code>java</code>,<code>python</code>的基础，否则对下面的代码很难理解，毕竟为了演示Socket通信的能力，我会尽力多去使用各种语言，以帮助大家建立起真正的网络系统模型</p><h2 id="数据接受端-C"><a href="#数据接受端-C" class="headerlink" title="数据接受端(C++)"></a>数据接受端(C++)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;WINSOCK2.H&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;windows.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib, <span class="hljs-meta-string">&quot;ws2_32.lib&quot;</span>) </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//定义数据套接字</span><br>    WSADATA wsaData;<br>    SOCKET Server;<br>    SOCKET Client;<br>    SOCKADDR_IN local;<br>    SOCKADDR_IN client;<br>    <span class="hljs-comment">//传过来的数据</span><br>    <span class="hljs-keyword">char</span> Messagesize[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">int</span> retu;<br>    <span class="hljs-keyword">int</span> iaddrSize = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(SOCKADDR_IN);<br>    <span class="hljs-built_in">WSAStartup</span>(<span class="hljs-number">0x0202</span>, &amp;wsaData);<br>    <span class="hljs-comment">//设置服务端</span><br>    Server = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);<br>    local.sin_family = AF_INET;<br>    <span class="hljs-comment">//设置端口</span><br>    local.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">8090</span>);<br>    <span class="hljs-comment">//得到地址</span><br>    local.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    <span class="hljs-comment">//监听服务</span><br>    <span class="hljs-built_in">bind</span>(Server, (struct sockaddr*)&amp;local, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(SOCKADDR_IN));<br>    <span class="hljs-built_in">listen</span>(Server, <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//得到客户端</span><br>    Client = <span class="hljs-built_in">accept</span>(Server, (struct sockaddr*)&amp;client, &amp;iaddrSize);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;服务器得到客户端的连接:%s:%d\n&quot;</span>, <span class="hljs-built_in">inet_ntoa</span>(client.sin_addr),<span class="hljs-built_in">ntohs</span>(client.sin_port));<br>    <span class="hljs-comment">//输出得到的内容</span><br>    <span class="hljs-keyword">while</span> (TRUE) &#123;<br>        retu = <span class="hljs-built_in">recv</span>(Client, Messagesize, <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>);<br>        Messagesize[retu] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;接收到数据 [%d 字节]: &#x27;%s&#x27;\n&quot;</span>, retu, Messagesize);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据发送客户端1号-Java"><a href="#数据发送客户端1号-Java" class="headerlink" title="数据发送客户端1号(Java)"></a>数据发送客户端1号(Java)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//配置Socket对象</span><br>            Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">8090</span>);<br>            <span class="hljs-comment">//定义输出流对象</span><br>            PrintWriter printWriter = <span class="hljs-keyword">new</span> PrintWriter(socket.getOutputStream());<br>            <span class="hljs-comment">//字符串转如Socket发送出去</span><br>            printWriter.write(<span class="hljs-string">&quot;Hey!Im java client&quot;</span>);<br>            <span class="hljs-comment">//释放空间</span><br>            printWriter.flush();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException exception) &#123;<br>            exception.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据发送客户端2号-Python"><a href="#数据发送客户端2号-Python" class="headerlink" title="数据发送客户端2号(Python)"></a>数据发送客户端2号(Python)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br>s = socket.socket()<br>s.connect((<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8090</span>))<br><br><span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>    s.send(<span class="hljs-string">&quot;Hi,Im python client&quot;</span>.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br>    data = s.recv(<span class="hljs-number">1024</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;recv:&#x27;</span>,data.decode())<br><br>s.close()<br></code></pre></td></tr></table></figure><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>均可在C++服务端上体现</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/socket/skt1.png" alt="python"></p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/socket/skt2.png" alt="java"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>任何基础知识都必须经过尝试才能知道背后的原理，如果只是做研究而不去尝试，永远不会知道实用性与自由性</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>通信技术</tag>
      
      <tag>java</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些神经网络的理解</title>
    <link href="/2021/12/13/%E4%B8%80%E4%BA%9B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2021/12/13/%E4%B8%80%E4%BA%9B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>人工智能(Artifical Intalligent)是人们研究自己的思考与行为，并将其复制出应用的科学。大脑是人体最复杂的器官，目前人类还无法自由控制修改它，只能做出一些黑盒测试，心理学就是这样，通过问题刺激大脑判断其生物反应以及做出的应答。</p><p>人脑的功能很多，它可以调控运动，接受形成感觉，完成语言与对话，拥有情绪并且能操作执行某些行为，这与人类理想的计算机是一样的。通过研究神经科学，人脑可以实现一下功能</p><p>1、自由切换认知模式，同时具有很多决策方式</p><p>2、拥有很多先天具有的处理问题的方法</p><p>3、拥有强大的表达能力已经对抽象事物的描述能力</p><p>4、可以通过学习的行为，迅速组合已有的技能组合成新的技能</p><p>5、具有独立的意识</p><p>人工智能要研究的内容都是参考人脑进行研究的，而上述的5点，目前只能做到前2点。</p><p>神经网络即人工神经网络(Artificial Neural Networks)[ANN]，一般是处理问题以及做出决策的数学模型。</p><h1 id="卷积神经网络-CNN"><a href="#卷积神经网络-CNN" class="headerlink" title="卷积神经网络[CNN]"></a>卷积神经网络[CNN]</h1><p>CNN全名卷积神经网络(Convolutional Neural Networks)，这是一种计算机深度学习最具代表性的算法之一，可以充分利用训练出的多组模型并自由组合。</p><p>卷积神经网络参考了人脑的功能，主要分为自主学习与监督学习，其隐含层内的卷积核参数共享和层间连接的稀疏性使得卷积神经网络能够以较小的计算量对格点化特征，具有稳定高效的特点。</p><h2 id="卷积神经网络模型"><a href="#卷积神经网络模型" class="headerlink" title="卷积神经网络模型"></a>卷积神经网络模型</h2><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/CNN/CNN1.png" alt="CNN1"></p><p>CNN算法通过不断地卷积与池化，实现对模型处理为隐含层的卷积核，将不同的数据与卷积核建立起联系，而不同的联系得到的结果不同，而组成的核与数据的网络就是卷积出的神经网络（像人脑的神经网），所以得名卷积神经网络</p><h2 id="卷积不是毫无根据的卷"><a href="#卷积不是毫无根据的卷" class="headerlink" title="卷积不是毫无根据的卷"></a>卷积不是毫无根据的卷</h2><p>所谓卷积，就是不断从样本中剥离出特征，每一个卷积核都对应着一个权重系数和一个偏移量[τ]（每一个都像神经纤维上的细胞体一样），而卷积需要一个视野，就像人脑看事物并不能同时处理整体，而是用一定的范围观察部分，多次反复观察从而得出对事物整体的认知，卷积也要这样做，这个视野叫做卷积核。</p><hr><p>卷积核就是一个二维的矩阵，矩阵中的每一个元素（卷积层参数）都像人眼中对不同色彩的敏感程度一样（图片解释）</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/CNN/CNN2.jpg" alt="CNN2"></p><p>举个生活中的例子吧，视野就是考试时你们老师在纸上烫出的洞（过滤器），而下面的样本就像你的答题卡，老师不会统计你做错多少，而是把纸放在你的答题卡上比较，统计出你有多少个重合的点，进而得出你的分数</p><p>在这个过程就像是在做矩阵的乘法一样，事实也确实如此，通过不断的识别扫描，通过卷积核留下矩阵点乘的结果。</p><blockquote><p>不知道矩阵乘法的看我</p></blockquote><p>矩阵乘法分为点乘和矩阵乘，点乘就是矩阵每个点乘加和</p><script type="math/tex; mode=display">X=\left[ \begin{matrix} a11 & a12 & c13 \\ a21 & a22 & a23 \\ a31 & a32 & a33\end{matrix} \right]</script><script type="math/tex; mode=display">Y=\left[ \begin{matrix} b11 & b12 & b13 \\ b21 & b22 & b23 \\ b31 & b32 & b33\end{matrix} \right]</script><p>X与Y分别表示两个等型矩阵</p><script type="math/tex; mode=display">A=\left[ \begin{matrix} a11 & a12 & c13 \\ a21 & a22 & a23 \\ a31 & a32 & a33\end{matrix} \right]×\left[ \begin{matrix} b11 & b12 & b13 \\ b21 & b22 & b23 \\ b31 & b32 & b33\end{matrix} \right]</script><p>点乘结果就可以表示成下面的形式</p><script type="math/tex; mode=display">B=\sum_{i=1}^n a_{ii}*b_{ii}</script><p>叉乘就是行乘列，叉乘得到的是新矩阵C，而新矩阵C的i行j列可以用下面的式子算出(依然是X*Y哦)</p><script type="math/tex; mode=display">C_{ij}=\sum_{k=1}^pa_{ik}*b_{kj}</script><p>点乘得出常数，叉乘得出新矩阵，这是一个点</p><blockquote><p>知道矩阵乘法的可以跳转到这里</p></blockquote><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/CNN/CNN3.jpg" alt="CNN3"></p><p>卷积核也可以叫做过滤器，就像人眼睛会过滤掉一些不适合的内容，最好的就是feature maps的例子</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/CNN/CNN4.jpg" alt="CNN4"></p><p>不断对图片进行卷积得到卷积层，层与层之间没有连接，要想实现，必须将卷积核（过滤器）连接，例如对RGB图片的处理，将图片分解为RGB三个通道，每个通道对应一个过滤器，每个过滤器彼此又相互联系</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/CNN/CNN5.jpg" alt="CNN5"></p><h2 id="池化的意义"><a href="#池化的意义" class="headerlink" title="池化的意义"></a>池化的意义</h2><p>1、在卷积层进行特征提取后，输出的特征图会被传递至池化层进行特征选择和信息过滤。池化层包含预设定的池化函数，其功能是将特征图中单个点的结果替换为其相邻区域的特征图统计量。</p><p>2、在激励层的激励函数最常用的不是sigmoid而是 ReLU （<strong>修正线性单元</strong>函数）λ为随机变量</p><script type="math/tex; mode=display">f(x)=\begin{cases}x & x>0\\λx&x≤0\\\end{cases}</script><p>3、输入层-&gt;隐含层-&gt;输出层</p><p>隐含层包括卷积层，池化层，（堆积<strong>Inception</strong>），全连接层</p><p>池化分为Max或Avg pooling，与卷积的扫描类似，池化也需要一个窗口去扫描，作为扫描窗口必须有步长(stride)</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/CNN/CNN6.png" alt="CNN6"></p><p>Max pooling就是取出扫描区块中的最大值，组成新的池中的数值，而Avg pooling就是取出扫描区域的平均值作为池中的数值，计算出新池中的数据后，经过ReLU的处理可以剔除不正常的数据，也就是负值，保证正常与协调。</p><h2 id="使用python实现对图片的卷积"><a href="#使用python实现对图片的卷积" class="headerlink" title="使用python实现对图片的卷积"></a>使用python实现对图片的卷积</h2><p>首先你要先有图片我这里使用下面的示范</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/img/background10.jpg" alt=""></p><p>将图片保存在同级目录下，命名为<code>1.jpg</code>，编写出以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> pyplot<br><span class="hljs-keyword">import</span> pylab<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>filename = <span class="hljs-string">r&quot;1.jpg&quot;</span><br><br><span class="hljs-comment"># 读取图片</span><br>testimg = pyplot.imread(filename)<br><span class="hljs-comment"># 配置卷积核，卷积核不同，得到的效果也不同</span><br>fil = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],<br>                      [<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],<br>                      [<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],<br>                      [-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>]])<br><br><span class="hljs-comment"># 使用卷积核对图片卷积并池化</span><br>result = cv2.filter2D(testimg,-<span class="hljs-number">1</span>,fil)<br><span class="hljs-comment"># 展示出卷积后的图片</span><br>pyplot.imshow(result)<br>pyplot.imsave(<span class="hljs-string">r&quot;C:\Users\13846\Desktop\result.jpg&quot;</span>,result)<br>pylab.show()<br></code></pre></td></tr></table></figure><p>得到的结果是这样的</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/CNN/CNN7.jpg" alt="CNN7"></p><h1 id="深度神经网络-DNN"><a href="#深度神经网络-DNN" class="headerlink" title="深度神经网络[DNN]"></a>深度神经网络[DNN]</h1><p>深度神经网络(Deep Neural Networks)[DNN]，可以理解为多个隐藏层并排放置的神经网络</p><h2 id="深度神经网络模型"><a href="#深度神经网络模型" class="headerlink" title="深度神经网络模型"></a>深度神经网络模型</h2><p>感知器是深度神经网络的一个微结构，他是一个有很多个输入，一个输出的模型，如图:</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/CNN/DNN1.png" alt="DNN1"></p><p>而经过学习可以得到下面的模型:</p><script type="math/tex; mode=display">z=\sum_{i=1}^n\omega_ix_i+b</script><p>其中<code>b</code>叫做偏移量<code>ω</code>则就是要训练出来的权重</p><p>为了限制输出的范围，对得出的y需要套上一个神经元激活函数，使得到的结果为1或-1，经常运用的激活函数是Sigmoid函数。</p><p>不过因为它只能输出两种类型的结果或者达到神经元函数饱和或过饱和时结果相同，这也导致了无法满足复杂的非线性模型，因此无法在工业生产使用，而只能做一些分类</p><p>因为每一个微结构都很简单所以组合起来复杂度就会非常高，这种模型用于计算回归，处理分类或者作为KNN与SVM另一种的分类算法存在，并且表达能力也非常强。</p><script type="math/tex; mode=display">Sigmoid(z)=\frac{1}{1+e^{-z}}</script><h2 id="DNN前向传播算法"><a href="#DNN前向传播算法" class="headerlink" title="DNN前向传播算法"></a>DNN前向传播算法</h2><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/CNN/DNN2.png" alt="DNN2"></p><p>利用上层输出计算下一层的输出叫做DNN的前向传播算法，和感知器类似，我们也可以使用同样的计算方法，设我选择的激活函数是σ(z)，指数位表达的是隐藏层，角码表达的是第几个神经元</p><script type="math/tex; mode=display">a^2_1=σ(z^2_1)=σ(ω^2_{11}x_1+ω^2_{12}x_2+ω^2_{13}x_3+ω^2_{14}x_4+b^2_1)</script><script type="math/tex; mode=display">a^2_2=σ(z^2_2)=σ(ω^2_{21}x_1+ω^2_{22}x_2+ω^2_{23}x_3+ω^2_{24}x_4+b^2_2)</script><script type="math/tex; mode=display">a^2_3=σ(z^2_3)=σ(ω^2_{31}x_1+ω^2_{32}x_2+ω^2_{33}x_3+ω^2_{34}x_4+b^2_3)</script><p>第L层共有m个神经元，则对于第L层的第j个神经元的输出得到公式:</p><script type="math/tex; mode=display">a^l_j=σ(z^l_j)=σ(\sum^m_{k=1}ω^l_{jk}a^{l-1}_k+b^l_j)</script><p>而每一个权重最终都可以表示在一个矩阵W中，所以也可以用矩阵表示</p><script type="math/tex; mode=display">a^l_j=σ(z^l_j)=σ(W^la^{l-1}+b^l)</script><h2 id="DNN反向传播算法"><a href="#DNN反向传播算法" class="headerlink" title="DNN反向传播算法"></a>DNN反向传播算法</h2><blockquote><p>因为我没学过高等数学，所以不懂什么是偏导，我就直接给个链接不搬运了<a href="https://blog.csdn.net/bitcarmanlee/article/details/78819025">https://blog.csdn.net/bitcarmanlee/article/details/78819025</a></p></blockquote><h1 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h1><p>神经网络是机器学习部分非常重要的算法，目前主要的三种可以解决很多问题，不如知道原理后放心使用。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>机器学习</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTPS、SSL、TLS的关系</title>
    <link href="/2021/12/03/HTTPS%E3%80%81SSL%E3%80%81TLS%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2021/12/03/HTTPS%E3%80%81SSL%E3%80%81TLS%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="发现地点"><a href="#发现地点" class="headerlink" title="发现地点"></a>发现地点</h2><p>其实最开始并不了解，只是有一次被DDos时忽然发现cloudflare的这个功能，于是便好奇了解一点</p><h2 id="SSL、TLS简介"><a href="#SSL、TLS简介" class="headerlink" title="SSL、TLS简介"></a>SSL、TLS简介</h2><p>SSL(Secure Socket Layer 安全套接层)是基于HTTPS下的一个协议加密层，是基于HTTP之下TCP之上的一个协议层，是基于HTTP标准并对TCP传输数据时进行加密。它是一项标准技术，可确保互联网连接安全，保护两个系统之间发送的任何敏感数据。两个系统可能是指服务器和客户端，或两个服务器之间。</p><hr><p>TLS（传输层安全）是更为安全的升级版 SSL。由于 SSL 这一术语更为常用，因此我们仍然将我们的安全证书称作 SSL。但当购买 SSL 时，您真正购买的是最新的 TLS 证书，有 ECC、RSA 或 DSA 三种加密方式可以选择。</p><hr><p>HTTPS则是使用TLS/SSL的HTTP，它并不在80端口运行，而是在443端口进行TCP/IP通信。HTTPS协议使用SSL在发送方把原始数据进行加密，然后在接受方进行解密，加密和解密需要发送方和接受方通过交换共知的密钥来实现，因此，所传送的数据更加安全。</p><hr><p>TLS/SSL是一种加密通道的规范，它利用对称加密、公私钥不对称加密及其密钥交换算法，CA系统进行加密且可信任的信息传输。</p><p>SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p><p>安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。</p><h2 id="SSL、TLS的区别"><a href="#SSL、TLS的区别" class="headerlink" title="SSL、TLS的区别"></a>SSL、TLS的区别</h2><p>SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。</p><p>TLS：（Transport Layer Security，传输层安全协议），用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。</p><p>1）报文鉴别码：SSLv3.0和TLS的MAC算法及MAC计算的范围不同。TLS使用RFC-2104定义的HMAC算法。SSLv3.0使用了相似的算法，两者差别在于SSLv3.0中，填充字节与密钥之间采用的是连接运算，而HMAC算法采用的异或运算。但是两者的安全程度是相同的。</p><p>2）伪随机函数：TLS使用了称为PRF的伪随机函数来将密钥扩展成数据块，是更安全的方式。</p><p>3）报警代码：TLS支持几乎所有的SSLv3.0报警代码，而且TLS还补充定义了很多报警代码，如解密失败（decryption_failed）、记录溢出（record_overflow）、未知CA（unknown_ca）、拒绝访问（access_denied）等。</p><p>4）密文族和客户证书：SSLv3.0和TLS存在少量差别，即TLS不支持Fortezza密钥交换、加密算法和客户证书。</p><p>5）certificate_verify和finished消息：SSLv3.0和TLS在用certificate_verify和finished消息计算MD5和SHA-1散列码时，计算的输入有少许差别，但安全性相当。</p><p>6）加密计算：TLS和SSLv3.0在计算主密值（master secret）时采用的方式不同。</p><p>7）填充：用户数据加密之前需要增加的填充字节。在SSL中，填充后的数据长度哟啊达到密文快长度的最小整数倍。而在TLS中，填充后的数据长度可以是密文块长度的任意整数倍（但填充的最大长度为255字节），这种方式可以防止基于对报文长度进行分析的攻击。</p><p>8）版本号：TLS记录格式与SSL记录格式相同，但版本号的值不同，TLS的版本1.0使用的版本号为SSLv3.1。</p><h2 id="TLS的优势"><a href="#TLS的优势" class="headerlink" title="TLS的优势"></a>TLS的优势</h2><p>1、更安全的MAC算法、更严密的警报</p><p>2、对于消息认证使用密钥散列法：TLS使用“消息认证代码的密钥散列法”（HMAC），当记录在开放的网络（如因特网）上传送时，该代码确保记录不会被变更。SSLv3.0还提供键控消息认证，但HMAC比SSLv3.0使用（消息认证代码）MAC功能更安全。</p><p>3、增强的伪随机功能（PRF）：PRF生成密钥数据。在TLS中，HMAC定义PRF。PRF使用两种散列算法保证其安全性。如果任一算法暴露了，只要第二种算法未暴露，则数据仍然是安全的。</p><p>4、改进的已完成消息验证：TLS和SSLv3.0都对两个端点提供已完成的消息，该消息认证交换的消息没有被变更。然而，TLS将此已完成消息基于PRF和HMAC值之上，这也比SSLv3.0更安全。</p><p>5、一致证书处理：与SSLv3.0不同，TLS试图指定必须在TLS之间实现交换的证书类型。</p><p>6、特定警报消息：TLS提供更多的特定和附加警报，以指示任一会话端点检测到的问题。TLS还对何时应该发送某些警报进行记录。</p><blockquote><p>文章摘自：<a href="https://blog.csdn.net/whatday/article/details/102369732/">https://blog.csdn.net/whatday/article/details/102369732/</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mirai框架开发QQ机器人</title>
    <link href="/2021/11/11/Mirai%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    <url>/2021/11/11/Mirai%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="QQ机器人"><a href="#QQ机器人" class="headerlink" title="QQ机器人"></a>QQ机器人</h2><p>酷Q机器人已经从叱诧风云的QQ机器人框架中消失，仅存的几款开源框架，不是效果不理想，就是自定义度不高。而Mirai就是这样一个框架，其内部的功能并不是很强大，但他对一些功能的封装并不严格，所以也就有机会能和底层进行交流。</p><h2 id="必要的知识"><a href="#必要的知识" class="headerlink" title="必要的知识"></a>必要的知识</h2><p>首先你要保证你已经掌握了Java或者kotlin的语法规则，并且能够写出最基本的代码(Hello world)</p><h1 id="安装MCL"><a href="#安装MCL" class="headerlink" title="安装MCL"></a>安装MCL</h1><h3 id="自动安装"><a href="#自动安装" class="headerlink" title="自动安装"></a>自动安装</h3><p><a href="https://github.com/iTXTech/mcl-installer">MCL Installer自动安装工具</a>可以获取到所有系统的<code>iTXTech MCL</code></p><h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><ol><li>安装 Java 运行时（版本必须 &gt;= 11）</li><li>从 <a href="https://github.com/iTXTech/mirai-console-loader/releases">Releases</a> 下载最新版本的<code>MCL</code></li><li>解压到某处</li><li>在命令行中执行<code>.\mcl</code>以启动<code>MCL</code></li><li>启动过程中或许会需要安装openjdk，不推荐安装（使用你自己安装的jdk就可以）</li><li>如果启动过程中出现类文件版本高低等问题，都可以通过修改jdk版本解决</li></ol><h2 id="下载Mirai"><a href="#下载Mirai" class="headerlink" title="下载Mirai"></a>下载Mirai</h2><h3 id="IDEA插件"><a href="#IDEA插件" class="headerlink" title="IDEA插件"></a>IDEA插件</h3><p>打开IDEA，在<code>文件-&gt;设置-&gt;插件</code>中搜索Mirai Console</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/mirai/1.png" alt=""></p><p>安装完成后重启IDEA，然后就可以新建一个Mirai项目了</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/mirai/2.png" alt=""></p><p>选择jdk版本，新版本使用11及以上</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/mirai/3.png" alt=""></p><p>你可以选择Kotlin或者Java，希望使用什么语言就选择什么语言，我这里用Java举例</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/mirai/4.png" alt=""></p><p>一些简单的基本信息</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/mirai/5.png" alt=""></p><p>文件路径</p><h3 id="开始编写"><a href="#开始编写" class="headerlink" title="开始编写"></a>开始编写</h3><p>创建新项目的过程可能会有点慢，静静等待一会就好了</p><p>新项目创建好的主类应该含有下面这些代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Plugin INSTANCE = <span class="hljs-keyword">new</span> Plugin();<br><span class="hljs-comment">//这里是注册方法</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Plugin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> JvmPluginDescriptionBuilder(<span class="hljs-string">&quot;主类&quot;</span>, <span class="hljs-string">&quot;1.0&quot;</span>)<br>                .name(<span class="hljs-string">&quot;插件名字&quot;</span>)<br>                .author(<span class="hljs-string">&quot;作者名&quot;</span>)<br>                .build());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//插件被加载时的方法</span><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLoad</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> PluginComponentStorage $<span class="hljs-keyword">this</span>$onLoad)</span> </span>&#123;<br>        <span class="hljs-comment">//一般在这里写有关配置文件的加载</span><br>    &#125;<br><span class="hljs-comment">//插件运行时的方法</span><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onEnable</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//主要功能的注册和事件的监听写在这里</span><br>    &#125;<br><span class="hljs-comment">//插件卸载时执行的方法</span><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDisable</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//一般这里写保存配置文件或者关闭流</span><br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="加载配置文件"><a href="#加载配置文件" class="headerlink" title="加载配置文件"></a>加载配置文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLoad</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> PluginComponentStorage $<span class="hljs-keyword">this</span>$onLoad)</span> </span>&#123;<br>    getConfigFolder();<span class="hljs-comment">//获取配置文件目录，是以你插件的名字命名的</span><br>&#125;    <br></code></pre></td></tr></table></figure><h4 id="默认代码"><a href="#默认代码" class="headerlink" title="默认代码"></a>默认代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onEnable</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//注册监听事件</span><br>        EventChannel&lt;Event&gt; eventChannel = GlobalEventChannel.INSTANCE.parentScope(<span class="hljs-keyword">this</span>);<br>        <br>        <span class="hljs-comment">//可以选择监听群聊消息</span><br>        eventChannel.subscribeAlways(GroupMessageEvent.class, g -&gt; &#123;<br>            <span class="hljs-comment">//监听群消息</span><br>            System.out.println(g.getMessage().contentToString());<br>        &#125;);<br>        <br>        <span class="hljs-comment">//也可以选择监听好友消息</span><br>        eventChannel.subscribeAlways(FriendMessageEvent.class, f -&gt; &#123;<br>            <span class="hljs-comment">//好友消息</span><br>            System.out.println(f.getMessage().contentToString());<br>        &#125;);<br>        <span class="hljs-comment">//事件的种类很多就不意一一列举了，不过写法都是类似的</span><br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">EventChannel&lt;Event&gt; eventChannel = GlobalEventChannel.INSTANCE.parentScope(<span class="hljs-keyword">this</span>);<br><span class="hljs-comment">//定义操作</span><br>eventChannel.subscribeAlways(事件种类.class, g -&gt; &#123;<br>    <span class="hljs-comment">//操作</span><br>&#125;);<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>事件</th><th>功能</th><th>可供选择的操作</th></tr></thead><tbody><tr><td>GroupEvent</td><td>群聊事件</td><td>.getBot()获取机器人Bot对象</td></tr><tr><td>FriendEvent</td><td>好友事件</td><td>.getBot()获取机器人Bot对象</td></tr><tr><td>StrangerEvent</td><td>陌生人事件</td><td>.getBot()获取机器人Bot对象</td></tr><tr><td>下面就是一些细化事件</td><td>—-</td><td>—-</td></tr><tr><td>FriendAddEvent</td><td>添加好友事件</td><td>.getFriend()获取添加者的Friend对象</td></tr><tr><td>StrangerAddEvent</td><td>陌生人添加事件</td><td>.getStranger()获取Stranger对象（一般Stranger都是临时会话的对象）</td></tr><tr><td>FriendAvatarChangedEvent</td><td>好友头像改变事件</td><td>.getBot()获取机器人Bot对象</td></tr><tr><td>MemberJoinEvent</td><td>群聊新成员加入事件</td><td>.getMember()获得成员对象</td></tr></tbody></table></div><h4 id="对象常用方法"><a href="#对象常用方法" class="headerlink" title="对象常用方法"></a>对象常用方法</h4><p>GroupEvent:</p><p>​    1、getBot()获取机器人</p><p>​    2、getGroup()获取群聊对象：</p><p>Group:</p><p>​    1、contains(QQ号)判断是否在群聊内</p><p>​    2、getAvatarUrl()获取群头像链接</p><p>​    3、getBotAsMember()作为群成员对象获取机器人</p><p>​    4、getBotMuteRemaining()查看机器人被禁言的剩余时间</p><p>​    5、getBotPermission()获得机器人许可等级</p><p>​    6、getMembers()获得某个群成员</p><p>​    7、getName()获得机器人的群昵称</p><p>​    8、getSettings()获得群聊的设置</p><p>​    9、sendMessage()在群聊发消息</p><p>FriendEvent:</p><p>​    1、getFriend()获得朋友对象</p><p>Friend：</p><p>​    1、sendMessage()发送消息</p><p>​    2、delete()删除好友</p><p>Member:</p><p>​    1、getNameCard()获得名片</p><p>​    2、isMuted()判断是否禁言</p><p>​    3、unmute()解除禁言</p><p><strong>更多的</strong>方法可以在IDEA中尝试，命名还是很好懂的</p><h4 id="消息元素"><a href="#消息元素" class="headerlink" title="消息元素"></a>消息元素</h4><p>在java中，一般这么构建消息链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">MessageChainBuilder builder = <span class="hljs-keyword">new</span> MessageChainBuilder();<br></code></pre></td></tr></table></figure><p>针对<code>builder</code>对象，我们可以对他插入消息元素等</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">AtAll.<span class="hljs-constructor">INSTANCE(@所有人)</span><br><span class="hljs-keyword">new</span> <span class="hljs-constructor">Face(Face.表情名)</span><br><span class="hljs-keyword">new</span> <span class="hljs-constructor">At(114514L)</span> (@某个人，加QQ号)<br></code></pre></td></tr></table></figure><hr><p>图片：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">EventChannel&lt;Event&gt; eventChannel = GlobalEventChannel.INSTANCE.parentScope(<span class="hljs-keyword">this</span>);<br>eventChannel.subscribeAlways(FriendEvent.class, event-&gt;&#123;<br>    <span class="hljs-comment">//发送本地图片</span><br>    <span class="hljs-comment">//构建资源对象</span><br>    ExternalResource res = ExternalResource.create(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;本地图片&quot;</span>));<br>    <span class="hljs-comment">//构建图片对象</span><br>    Image image = event.getFriend().uploadImage(res);<br>    <span class="hljs-comment">//关闭资源流</span><br>    res.close();<br>    <span class="hljs-comment">//发送图片</span><br>    event.getFriend().sendMessage(image);<br>&#125;);<br></code></pre></td></tr></table></figure><p>也可以通过图片ID发送图片，不过图片ID一般看不到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">EventChannel&lt;Event&gt; eventChannel = GlobalEventChannel.INSTANCE.parentScope(<span class="hljs-keyword">this</span>);<br>eventChannel.subscribeAlways(FriendEvent.class, event-&gt;&#123;<br>    <span class="hljs-comment">//发送图片</span><br>    event.getFriend().sendMessage(Image.fromId(<span class="hljs-string">&quot;图片ID&quot;</span>));<br>&#125;);<br></code></pre></td></tr></table></figure><p>发出声音：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">EventChannel&lt;Event&gt; eventChannel = GlobalEventChannel.INSTANCE.parentScope(<span class="hljs-keyword">this</span>);<br>eventChannel.subscribeAlways(FriendEvent.class, event-&gt;&#123;<br>    <span class="hljs-comment">//还是资源对象</span><br>ExternalResource res = ExternalResource.create(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;声音文件.amr&quot;</span>));<br>Audio audio = event.getFriend().uploadAudio(res); <span class="hljs-comment">// 适用于2.7+</span><br><span class="hljs-comment">// Voice audio = contact.uploadVoice(res); // 可用于2.0~2.7</span><br><span class="hljs-comment">//关闭资源流</span><br>res.close();<br>event.getFriend().sendMessage(audio);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>新建一个java文件，命名随意，我这里使用了echo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 指令类 <span class="hljs-keyword">extends</span> <span class="hljs-title">JSimpleCommand</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> 指令类 INSTANCE = <span class="hljs-keyword">new</span> 指令类();<br><br>    <span class="hljs-comment">//构造函数，用于初始化对象</span><br>    <span class="hljs-keyword">private</span> 指令类() &#123;<br>        <span class="hljs-keyword">super</span>(主类名.INSTANCE, <span class="hljs-string">&quot;指令&quot;</span>, <span class="hljs-string">&quot;功能&quot;</span>);<br>        <span class="hljs-keyword">this</span>.setDescription(<span class="hljs-string">&quot;描述&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Handler</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(CommandSender sender, User target, String msg)</span> </span>&#123;<br>        <span class="hljs-comment">//然后就可以实现你的算法了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在主类内进行注册指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在启用运行函数内注册方法</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onEnable</span><span class="hljs-params">()</span> </span>&#123;<br>    CommandManager.INSTANCE.registerCommand(指令类.INSTANCE, <span class="hljs-keyword">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插件的编译"><a href="#插件的编译" class="headerlink" title="插件的编译"></a>插件的编译</h3><p>在项目构建工具的右侧，会有一条工具栏，侧边的Gradle中点击拉开build，找到jar工具，双击即可编译出jar文件</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/mirai/6.png" alt=""></p><p>导出的jar文件在你的项目路径下<code>build/libs/文件名.jar</code>将他拖入MCL启动器的plugins文件夹下</p><h1 id="配置MCL"><a href="#配置MCL" class="headerlink" title="配置MCL"></a>配置MCL</h1><p>在上述操作完成后，可以打开MCL启动器的目录，找到<code>config/Console/AutoLogin.yml</code>，向里面添加你的机器人QQ，方便之后进行自动登录，第一次登录可能会出现拦截，不过只需在一部<em>手机</em>上打开弹窗的链接，进行安全认证即可</p><hr><p>MCL的其他文件夹或文件的功能我就不多赘述了，当你完成上述操作后，回到MCL的根路径下，就可以开启机器人了</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/mirai/7.png" alt=""></p><p>(放一张正常运行的图片)</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>如果有不会的可以查看大佬的非官方文档（虽然是kotlin，不过大体是相似的）</p><p>觉得不错就分享出去吧~</p><blockquote><p><a href="https://mirai.mamoe.net/topic/802">https://mirai.mamoe.net/topic/802</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Muiu插件</title>
    <link href="/2021/09/10/Muiu%E6%8F%92%E4%BB%B6/"/>
    <url>/2021/09/10/Muiu%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Muiu开源发布啦！下面是一些具体描述以及原理插件。名字是无意中打出来的，为了区分小米的米柚，咱的插件叫<strong>木鱼</strong></p><h2 id="功能原理"><a href="#功能原理" class="headerlink" title="功能原理"></a>功能原理</h2><p>这里为大家介绍一下MUIU的原理</p><p>MUIU使用了余弦相似度。余弦相似度也叫余弦相似性，余弦相似度用向量空间中两个向量夹角的余弦值作为衡量两个个体间差异的大小。余弦值越接近1，就表明夹角越接近0度，也就是两个向量越相似，这就叫”余弦相似性”。</p><p>如果想要深入了解原理，可以查看<a href="https://blog.csdn.net/zz_dd_yy/article/details/51926305的介绍，我就不搬运复述了">https://blog.csdn.net/zz_dd_yy/article/details/51926305的介绍，我就不搬运复述了</a></p><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>经过Minloha的反复测试，最后处理到的结果显示，MUIU具有监督学习能力，只要有一个情感色彩指向性强烈的词库，可以做到精准拦截(插件自带的词库可以解决很大程度的问题，具体情况根据服务器状况来定制)，拥有广告拦截功能，词库内部添加几种广告的格式便可以实行精确拦截，同时在处理拆分文本也有很强大的功能，在使用特殊字符时也能进行有效拦截，同时也会在服务器端明确标注信息</p><hr><h3 id="全部功能叙述"><a href="#全部功能叙述" class="headerlink" title="全部功能叙述"></a>全部功能叙述</h3><p>1、可以通过计算文本相似度来分析言论是否违规</p><p><img src="https://i0.hdslb.com/bfs/article/2c5e311d77a4073c0650035a80f678c08c8a2e32.png@942w_629h_progressive.webp" alt=""></p><p>2、可以导出html文件，方便查看</p><p>3、可以在云端开启在线管理功能</p><p><img src="https://i0.hdslb.com/bfs/article/5253d1edbb38f0c81b3f285a3837324d9d61cb48.png@942w_531h_progressive.webp" alt=""></p><p>4、拥有对话机器人的功能，满足服务器无聊问题的应答</p><p>5、原创的禁言与解封功能，实现对原版的扩展</p><p><img src="https://i0.hdslb.com/bfs/article/f7d18fb8a5e15cdf503f1a22c8dd9b79a5ab9605.png@917w_341h_progressive.webp" alt=""></p><p><img src="https://i0.hdslb.com/bfs/article/8bbcbabd9bdb9e555c5f6353fba4e40fb0df0393.png@942w_255h_progressive.webp" alt=""></p><p>​    自然也可以实时查看</p><p><img src="https://i0.hdslb.com/bfs/article/1fa766323d900ba6165f43b86b0875ce79f2111e.png@887w_219h_progressive.webp" alt=""></p><p>​    禁言效果：</p><p><img src="https://i0.hdslb.com/bfs/article/677ea1d39115fb5b6ba6ba3b1a5e2fe36ce25d93.png@942w_497h_progressive.webp" alt=""></p><p><img src="https://i0.hdslb.com/bfs/article/970db15d1d32801f155c0a20366465fafda952fe.png@891w_191h_progressive.webp" alt=""></p><p><img src="https://i0.hdslb.com/bfs/article/5af4a279308d93f43c27cee7bf12bed7cfb2f9ff.png@920w_404h_progressive.webp" alt=""></p><p>6、可以对玩家进行大字警告，效果更直观</p><p><img src="https://i0.hdslb.com/bfs/article/c4472f3d984d6ca3074111ca3bab3e3cb573f756.png@942w_416h_progressive.webp" alt=""></p><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p>Github：<a href="https://github.com/iMinloha/Muiu.git">https://github.com/iMinloha/Muiu.git</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏</tag>
      
      <tag>java</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[UTG]把Ubuntu变成Ubuntu to go</title>
    <link href="/2021/08/05/ubuntu%20to%20go/"/>
    <url>/2021/08/05/ubuntu%20to%20go/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Ubuntu to go其实是一个很早以前就有的技术了，但是因为相关介绍都是在Ubuntu16或Ubuntu18版本的</p><p>对现在的ubuntu20有些新鲜，所以我讲详细叙述一下Ubuntu20怎么做UTG</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>首先需要一个Ubuntu20的镜像，你可以从国内的镜像源下载</p><p><a href="http://mirrors.aliyun.com/ubuntu-releases/20.04/">http://mirrors.aliyun.com/ubuntu-releases/20.04/</a></p><ol><li>镜像</li><li>虚拟机软件</li><li>大于8G的u盘</li><li>双手</li></ol><blockquote><p>特别注意</p></blockquote><p>安装前关闭一切会读取U盘的杀毒软件，如果是windows10用户，一定要关闭自动播放功能</p><p>不然就会出现  无法操作文件  的错误</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>创建一个自定义的虚拟机</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/utg/1.png" alt=""></p><p>选择Ubuntu 64位</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/utg/2.png" alt=""></p><p>稍后使用镜像</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/utg/3.png" alt=""></p><p>使用物理磁盘</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/utg/4.png" alt=""></p><p>选择你的磁盘</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/utg/5.png" alt=""></p><blockquote><p>重新修改</p></blockquote><hr><p>打开虚拟机设置，选择CD/DVD使用ISO镜像</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/utg/6.png" alt=""></p><p>点击上面的选项=&gt;高级=&gt;修改固件类型</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/utg/7.png" alt=""></p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>进入虚拟机，先点击试用，在左下角的菜单栏打开终端，输入下面的指令，修复UEFI引导</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">sudo apt-add-repository ppa:yannubuntu/<span class="hljs-keyword">boot</span>-repair<br>sudo apt <span class="hljs-keyword">update</span><br>sudo apt install <span class="hljs-keyword">boot</span>-repair<br>sudo <span class="hljs-keyword">boot</span>-repair<br></code></pre></td></tr></table></figure><p>启动boot-repair之后，点击最大的按钮并等待即可</p><p>打开安装程序，选择你可以看懂的文字以及能用的输入法</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/utg/8.png" alt=""></p><p>选择最小安装，接下来选择其他选项，自己选择分区</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/utg/9.png" alt=""></p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/utg/10.png" alt=""></p><p>我的U盘大小是16G，所以我用200mb用于EFI引导，2000mb用于交换分区，其余的用于安装系统文件</p><p>如果你硬盘够大或者有其他需求可以自由分配，记得将ext4挂载在 “  /  “ 目录</p><p>详细分区：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">EFI</span>                    逻辑分区      <span class="hljs-number">200</span>mb<br><span class="hljs-attribute">ext4</span>     /boot      主分区       <span class="hljs-number">200</span>mb<br><span class="hljs-attribute">swap</span>                  主分区       <span class="hljs-number">2000</span>mb<br><span class="hljs-attribute">ext4</span>         /         主分区    剩余的全部空间<br></code></pre></td></tr></table></figure><blockquote><p>解释</p></blockquote><p>EFI引导启动系统,boot引导启动grub，swap将部分硬盘空间当RAM使用，ext4日志分区，用于安装系统</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/utg/11.png" alt=""></p><p>然后选择地区与国家，输入姓名与密码，然后等待安装完成</p><blockquote><p>漫长的等待后</p></blockquote><h3 id="接近尾声"><a href="#接近尾声" class="headerlink" title="接近尾声"></a>接近尾声</h3><p>安装完成后不要重启，不要重启</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/utg/12.png" alt=""></p><p>查看一下分区情况是否写入成功</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo -s</span><br><span class="hljs-attribute">fdisk -l</span><br></code></pre></td></tr></table></figure><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/utg/13.png" alt=""></p><p>关闭的方法直接将U盘热拔出就可以，如果关闭虚拟机的话，一些杀毒软件会打开U盘，那样就前功尽弃了</p><p>直接拔出U盘然后关闭电脑即可</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>将UTG的u盘插入电脑，在电脑开机狂按F12(不同主板，bios进入方式不同)然后你就能看到Ubuntu的字样</p><p>自此就结束了</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>装机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS的LeanCloud试玩</title>
    <link href="/2021/06/26/LeanCloud/"/>
    <url>/2021/06/26/LeanCloud/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>LeanCloud是一款免费的后端数据存储引擎，不仅用法简单方便，而且免费！免费！免费！</p><p>LeanCloud据官方介绍，它是一款基于Redis分布式存储的平台，可以实现用户多点查询，而且每日查询次数也是十分充足它可以满足一般的项目需求，支持js,java,php,python等语言，语法也非常简单</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/leancloud/lc%20(1" alt="">.png)</p><p>有账号直接登录，根据对应框填写信息即可</p><h2 id="获取ID"><a href="#获取ID" class="headerlink" title="获取ID"></a>获取ID</h2><p>登录成功后一般会要求先实名认证，这里直接认证就可以</p><p>实名认证成功后打开控制台，点击左上角创建应用，根据描述填写对应信息</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/leancloud/lc%20(2" alt="">.png)</p><p>创建成功后可以进入查看，进入之后选择设置</p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/leancloud/lc%20(3" alt="">.png)</p><p>再点击应用凭证，可以查看到自己的APPID和AppKey，这两个非常重要，记得保存一下</p><h2 id="选择语言"><a href="#选择语言" class="headerlink" title="选择语言"></a>选择语言</h2><p>这里我采用Js进行示范</p><p>你可以在<a href="https://leancloud.cn/docs/看到官方文档">https://leancloud.cn/docs/看到官方文档</a></p><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>首先导入LeanCloud的数据存储JS库</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//cdn.jsdelivr.net/npm/leancloud-storage@4.11.1/dist/av-min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后创建对应的对象</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">const &#123; Query, <span class="hljs-keyword">User</span> <span class="hljs-title">&#125; = AV</span>;<br></code></pre></td></tr></table></figure><p>注册AV对象</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts">AV.init(&#123;<br><span class="hljs-symbol">  appId:</span> <span class="hljs-string">&quot;你的APPID&quot;</span>,<br><span class="hljs-symbol">  appKey:</span> <span class="hljs-string">&quot;你的APPKey&quot;</span>,<br><span class="hljs-symbol">  serverURL:</span> <span class="hljs-string">&quot;你绑定的域名&quot;</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>最后创建对应数据村粗里结构化数据的Class创建对象</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">const</span> TestObject = AV.<span class="hljs-keyword">Object</span>.extend(<span class="hljs-string">&#x27;你的类名&#x27;</span>);<br><span class="hljs-keyword">const</span> testObject = <span class="hljs-keyword">new</span> TestObject();<br>testObject.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;列名&#x27;</span>, <span class="hljs-string">&#x27;数据内容&#x27;</span>);<br>testObject.<span class="hljs-built_in">save</span>().then((testObject) =&gt; &#123;<br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;保存成功。&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>查看一下控制台，如果发现数据存进去了，就说明成功了</p><p>这里要注意一下，必须先手动创建Class和对应的列名才可以存储</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>利用js也可以查询leancloud内存储的数据，查询对象包括字串与数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> query = <span class="hljs-keyword">new</span> AV.Query(<span class="hljs-string">&#x27;类名&#x27;</span>);<br>query.equalTo(<span class="hljs-string">&#x27;列名&#x27;</span>, <span class="hljs-string">&#x27;满足条件&#x27;</span>);<br>query.find().then(<span class="hljs-function">(<span class="hljs-params">List</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// List 是包含满足条件的对象的数组</span><br>    <span class="hljs-comment">//然后就可以遍历出满足条件的数据了</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>也可以根据使用限制条件进行查询，比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">query.notEqualTo(<span class="hljs-string">&#x27;类目&#x27;</span>, <span class="hljs-string">&#x27;条件&#x27;</span>);<span class="hljs-comment">//notEqualTo是排除查询，将条件之外的数据查询出并返回</span><br></code></pre></td></tr></table></figure><p>对于可以进行操作符限制属性（数字，字符串等），可以用以下方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 限制 age &lt; 18</span><br>query.lessThan(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-comment">// 限制 age &lt;= 18</span><br>query.lessThanOrEqualTo(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-comment">// 限制 age &gt; 18</span><br>query.greaterThan(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-comment">// 限制 age &gt;= 18</span><br>query.greaterThanOrEqualTo(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><p>查询字符串也是可以的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> query = <span class="hljs-keyword">new</span> AV.Query(<span class="hljs-string">&#x27;类名&#x27;</span>);<br><span class="hljs-comment">//多查询</span><br>query.startsWith(<span class="hljs-string">&#x27;列名&#x27;</span>, <span class="hljs-string">&#x27;起点&#x27;</span>);<br><span class="hljs-comment">//单查询</span><br>query.contains(<span class="hljs-string">&#x27;列名&#x27;</span>, <span class="hljs-string">&#x27;目标&#x27;</span>);<br><span class="hljs-comment">//正则查询</span><br><span class="hljs-keyword">const</span> regExp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(表达式);<br>query.matches(<span class="hljs-string">&#x27;列名&#x27;</span>, regExp);<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>LeanCloud对于实现记录一些信息的功能还是非常够用的，不过对与需要长时间保存或者需要更高安全性的还是使用云数据库或者其他的云服务吧~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你要躺平还是要内卷?</title>
    <link href="/2021/06/14/%E8%AE%BA%E8%BA%BA%E5%B9%B3%E4%B8%8E%E5%86%85%E5%8D%B7/"/>
    <url>/2021/06/14/%E8%AE%BA%E8%BA%BA%E5%B9%B3%E4%B8%8E%E5%86%85%E5%8D%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>躺平与内卷</p></blockquote><p>在社会生活中，我们会遇到各种各样的人或事，这其中不乏两类人，躺平的人和内卷的人</p><p>躺平一般是指指无论对方做出什么反应，你内心都毫无波澜，对此不会有任何反应或者反抗，表示顺从心理。换句话说就是避免竞争主义</p><p>内卷是个学术名词，举例子解释就是一群人去争一个饼，每个人都为了并不断地努力，最终导致收益与努力不成正比。现在则指努力改变的人</p><p>前段时间，一段来自衡水中学的一段演讲走火了，一方面是说了很多家长希望的孩子能够摆脱平凡的生活，另一方面则充分的展现了国内刻板的教育模式。</p><p>这篇演讲的初衷是想证明衡水中学不是考试工厂，学生们也都不是考试机器。但他的演讲起到了反作用，让我们看到了衡水中学对学生的塑造。这次的演讲透露了很多的问题。</p><p>我和他很像，但又不一样，我是普高，他是重点高中学，从地位上就已经拉开了很大的差距，所以我的观点都是建立在底层往高看，而非是在第三者的视角</p><h2 id="视频传送门"><a href="#视频传送门" class="headerlink" title="视频传送门"></a>视频传送门</h2><p><a href="https://www.bilibili.com/bangumi/play/ep407243">https://www.bilibili.com/bangumi/play/ep407243</a></p><h2 id="看法"><a href="#看法" class="headerlink" title="看法"></a>看法</h2><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/donot/1.png" alt=""></p><p>关于人应该是躺平还是内卷，我个人还是保持积极的看法的，努力的人不一定成功，但不努力一定不成功，在社会的内卷大潮流中就像波涛汹涌的海面一样，每个人都是在海上的一条船，平躺就像把船帆落下随波逐流，最后可能会被海浪拍在沙滩上，或者被大海撕碎。而内卷就像扬帆与海浪抗争，也有成功闯过大海的人，也会有被大海撕碎的人，无论什么做事情都不会是必然的结果，就像宇宙一样。与之避而不谈，不如直面挑战，至少不会在未来说：”如果我当时…….”</p><hr><p>在演讲中，最让人关注的就是那句”人们过着周而复始、循规蹈矩的生活，一眼，仿佛就能看到死”，这句话在演讲中出现，我很震惊，什么样的生活算平凡？周而复始的生活就平凡吗？当你能够掀起波浪的时候，最先考虑的事情不是继续努力而是稳固自己吧。</p><p>没有人生来优秀，所有的一切都是后天努力的结果。你生来所具有的东西不是你的，也不是你骄傲的资本，真正骄傲的东西应该是努力的结果，是在经历了一番苦难与磨练之后永远留在心底的东西。</p><p>反观下来，他的内卷主义已经触及到了很多人的生活方式，很多人认为他不应该嘲笑平凡的生活，仔细想想我们作为当代的新鲜血液，为什么不去奔腾？</p><p>“中国需要人才，而不是钱财”，在奔跑中，我们不需要记住一件事情，我们的努力不是为了资本与声望，从古至今，没有任何人存在的目的就是为了钱与利益，而是为了永远的存在这个世界上，我们有再富有，也终究会有人比我们更加的富有，而一个人真正的追求，应该是永远的存在与这个世界，至少能让人记得这个世界曾有个你。</p><p>我的人生观仅供参考，如果你全盘接受反倒是不正确的，取出适合你得部分，这便是意义所在。Minloha的最高追求就是学遍所有的东西。</p><p>我们没办法改变世界的格局，也没办法改变国家，我们能做到的只有利用自己的优势去活下去。躺平的安逸就如同毒药一般，足以让人麻痹，振奋起自己吧！青年！大格局大环境都是在推动去努力，既然做不到抵抗风浪，不如顺着风浪，终有一日，你可以自己激起波澜！</p>]]></content>
    
    
    <categories>
      
      <category>新事物</category>
      
    </categories>
    
    
    <tags>
      
      <tag>三观</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>鸿蒙系统开发工具的安装</title>
    <link href="/2021/06/03/%E9%B8%BF%E8%92%99%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/"/>
    <url>/2021/06/03/%E9%B8%BF%E8%92%99%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>6月3日凌晨2点21分，华为发布了最新的鸿蒙系统(HarmonyOS 2.0)</p><p>鸿蒙系统采用了面向全场景的分布式操作系统，以手机为主，扩展更多传统设备，未来可期</p><p>同时，鸿蒙系统采用了一个超级终端，满足了个人资源的自由调用，也让更多开发者都能进行拓展开发</p><h2 id="试用"><a href="#试用" class="headerlink" title="试用"></a>试用</h2><p>HarmonyOS采用了自家的编译器DevEco studio进行开发，你可以在官网处(<a href="https://developer.harmonyos.com/cn/develop/deveco-studio#download">https://developer.harmonyos.com/cn/develop/deveco-studio#download</a>)<br>下载自家的编译器</p><p>内部则可以使用C++/Java/Js进行开发</p><p>打开后就会有一个像android studio一样的操作界面</p><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p>(1):打开DevEco Studio，在欢迎页点击Create HarmonyOS Project，创建一个新工程。</p><p>(2):根据工程创建向导，选择需要的Ability工程模板，然后点击Next。关于工程模板的介绍和支持的设备类型，请参考<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/device_template-0000001053702407">支持的设备模板和编程语言</a></p><p><img src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20210603145203.76930725071818537260663788912908:50520602072441:2800:85EDB7056CFE7641A1C7185E729D8B4FCD7BF869EF6D3CA031347E617E0C487E.png?needInitFileName=true?needInitFileName=true" alt=""></p><p>(3):填写工程相关信息，Device Type选择Phone，其他保持默认值即可，点击Finish。</p><p><img src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20210603145203.62470303028492835414489709768262:50520602072441:2800:72D3A51492BFA67AC978615E776DC8F4AD05352D4DB52DA498E7ACABDBD0EA63.png?needInitFileName=true?needInitFileName=true" alt=""></p><blockquote><p>可以参考Android Studio的使用方法</p></blockquote><h3 id="下载和安装模拟器"><a href="#下载和安装模拟器" class="headerlink" title="下载和安装模拟器"></a>下载和安装模拟器</h3><p>(1):DevEco Studio提供远程模拟器和本地模拟器，本示例以远程模拟器为例进行说明。</p><p>(2):在DevEco Studio菜单栏，点击Tools &gt; Device Manager。</p><p>在浏览器中弹出华为开发者联盟帐号登录界面，请输入已实名认证的华为开发者联盟帐号的用户名和密码进行登录</p><p>(3):登录后，请点击界面的允许按钮进行授权。</p><p><img src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20210603145204.57864751338433815349013907494301:50520602072441:2800:667885C997B440C1207E21F6790089946D08B2796F5FABC80E07267A3C528875.png?needInitFileName=true?needInitFileName=true" alt=""></p><p>(4):在设备列表中，选择Phone设备，并点击<img src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20210603145204.10231095390058313368750322139178:50520602072441:2800:77F17402E950BCBE8EDDA84EB2757208F01E07F1E29638321A5FC19E597560FA.png?needInitFileName=true?needInitFileName=true" alt="">按钮，运行模拟器。</p><p><img src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20210603145204.06708903617624925946320618194151:50520602072441:2800:58CBB0553EA988B01BF9A1081337B1F4E621F21E49C5A2687CD06F2445418D97.png?needInitFileName=true?needInitFileName=true" alt=""></p><p>(5):点击DevEco Studio工具栏中的<img src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20210603145204.76425334528631336832184643354227:50520602072441:2800:4CD6C6E3EDDBF3D163E13EA23C964FDB1416B9953E3B575AEE0DF21A40D941D6.png?needInitFileName=true?needInitFileName=true" alt="">按钮运行工程，或使用默认快捷键Shift+F10（Mac为Control+R）运行工程。</p><p><img src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20210603145204.23816813212155850894766587743188:50520602072441:2800:D9F8FBD053FA810216B63D21E45C222B076C7607DB6E0A63FC3CE86B98AD324F.png?needInitFileName=true?needInitFileName=true" alt=""></p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>经过一圈使用发现，鸿蒙系统与以往的安卓开发比差别不大，鸿蒙系统提供了一套高效的库，可以节省部分时间</p><p>同时鸿蒙系统对硬件的占用还是相当的有发展空间的，总的来讲还是有很大的发展空间的</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一道圆锥曲线题目</title>
    <link href="/2021/05/05/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF%E9%97%AE%E9%A2%98/"/>
    <url>/2021/05/05/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/question/题.png" alt=""></p><p>如图，首先看一下问题，已知的只有一个椭圆的方程和一个三角形面积</p><h2 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h2><p>证明$x_1$²+$x_2$²与$y_1$²+$y_2$²均为定值</p><p>先设直线斜率k等于$\frac{y_2-y_1}{x_2-x_1}$</p><p>接下来进行分类讨论:</p><p>当K=0时，$x_2$=$x_1$,$y_2$=-$y_1$</p><p>当K≠0时，|$x_1$|·|$y_1$|=$\frac{\sqrt[2]{6}}{2}$</p><p>联立椭圆方程，则有 $x_1$²+$x_2$²=3  | $y_1$²+$y_2$²=2</p><p>所以$x_1$²+$x_2$²与$y_1$²+$y_2$²均为定值</p><blockquote><p>当然还有一种更为通俗的解法</p></blockquote><p>根据要求的解，我们首先应该想到韦达定理，那么就可以设直线方程为</p><p>y=kx+b</p><p>由题意可知，b≠0，代入椭圆方程</p><p>(2+3k²)x²+6kmx=3(m²-2)=0</p><p>根据判别式⊿=36k²m²-12(2+3k²)(m²-2)＞0</p><p>有3k²+2&gt;m²</p><p>$x_1$+$x_2$=-$\frac{6km}{2+3k²}$，$x_1$$x_2$=$\frac{3(m²-2)}{2+3k²}$</p><p>根据弦长公式，有PQ长度为$\sqrt[2]{1+k² }$·$\frac{2\sqrt[2]{6}\sqrt[2]{3k²+2-m²}}{2+3k²}$</p><p>根据点到直线距离公式，可以列出距离d=$\frac{|m|}{\sqrt[2]{1+k²}}$</p><p>那么面积$S_{OPQ}$=$\frac{1}{2}$|PQ|d</p><p>而面积又等于$\frac{\sqrt[2]{6}}{2}$</p><p>代入化简，有:</p><p>$x_1$²+$x_2$²=3  | $y_1$²+$y_2$²=2</p><p>所以结论成立</p><blockquote><p>虽然第二种方法计算量大，但是一般不会出错，具体看能接受哪种方法了</p></blockquote><h2 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h2><p>∵4|OM|²+|PQ|²=($x_1$+$x_2$)²+($y_1$+$y_2$)²+($x_2$-$x_1$)²+($y_2$-$y_1$)²=10</p><p>∴2|OM|·|PQ|≤$\frac{4|OM|²+|PQ|²}{2}$=5</p><p>所以|OM|·|PQ|最大值为$\frac{5}{2}$</p><h2 id="第三问"><a href="#第三问" class="headerlink" title="第三问"></a>第三问</h2><p><img src="https://cdn.minloha.cn/blog/images/question/pass.png" alt=""></p><blockquote><p>部分答案取自<a href="https://wenku.baidu.com/link?url=reuUhuCNZ131AA4UjNCCRFgkH8xyWcr8CByEUJCs2vcWKqBA5RNSqs2jOpuW5bG6_x1zJ7pcySktfZNlQglKhQRFw7y_frj3IxBsAHSOW1e">百度</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gridea主题</title>
    <link href="/2021/05/04/Gridea%E4%B8%BB%E9%A2%98/"/>
    <url>/2021/05/04/Gridea%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在2月~4月末期间，我在着手编写一款Gridea的主题，同时也用作个人博客的主题，现在它开源了</p><p>这是一款Gridea的主题，使用简单快速，并且有丰富的功能以及高度的可扩展性，你可以对他进行扩展</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>你可以通过我的Github仓库进行克隆：<a href="https://github.com/iMinloha/purem.git">https://github.com/iMinloha/purem.git</a></p><p><img src="https://minloha.oss-cn-hongkong.aliyuncs.com/blog/page/purem/blog.png" alt=""></p><h2 id="配置问题"><a href="#配置问题" class="headerlink" title="配置问题"></a>配置问题</h2><p>对于配置文件CDN，你只需要将Gridea所生成的media文件夹与styles文件夹上传到CDN即可</p><p>如果没有文件CDN，留空即可</p><p>文件:assets\media\scripts</p><p>anime.min.js 烟花特效的库js</p><p>des.js 点开次数统计</p><p>dialog.js 分享二维码的相关js</p><p>fireworks.js 烟花特效</p><p>index.js 移动端菜单栏的相关js</p><p>mouse_text.js 点击body时出现的悬浮文字</p><p>time_add.js 时间累加</p><h2 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h2><p>目前博客模板已经停止更新，一切收费活动与本人无关</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>各大视频网站的VIP解析</title>
    <link href="/2021/03/24/%E8%A7%86%E9%A2%91vip%E8%A7%A3%E6%9E%90/"/>
    <url>/2021/03/24/%E8%A7%86%E9%A2%91vip%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这个页面有附属脚本，酌情访问</p></blockquote><p>这里是Minloha的小站，今天在这里开一个小功能，VIP解析，代码在下面，没多少技术</p><style>.ipt{    width: 80%;    border: 1px solid #ccc;                 padding: 7px 0px;                border-radius: 3px;    border: 1px solid #ccc;                padding: 7px 0px;                border-radius: 3px;                padding-left:5px;                -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075);                box-shadow: inset 0 1px 1px rgba(0,0,0,.075);                -webkit-transition: border-color ease-in-out .15s,-webkit-box-shadow ease-in-out .15s;                -o-transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s;                transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s    border-color: #66afe9;                    outline: 0;                    -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);                    box-shadow: inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)                padding-left:5px;}.btn{    width: 10%;    height: 50px;    border-width: 0px;     border-radius: 3px;    background: #1E90FF;     outline: none;    font-family: Microsoft YaHei;     color: white; /* 字体颜色 */}</style><p><input type="text" placeholder="在此处输入链接" class="ipt" id="ipt"/></p><p><button onclick="on()" class="btn">GO!</button><br><br><br></p><h2 id="正式介绍"><a href="#正式介绍" class="headerlink" title="正式介绍"></a>正式介绍</h2><blockquote><p>首先我们需要一个html</p></blockquote><p>这个很简单，基本随随便便写写就行</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 可以插入一些css或js，这里直接放出来了 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;在此处输入链接&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ipt&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ipt&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;on()&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>点我前往<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后就是一个API，其实这个就是造壳子而已，加入一小段js</p><script>function on(){    var id=document.getElementById('ipt').value;    var url ="http://www.wmxz.wang/video.php?url="+id;    var reg=/^([hH][tT]{2}[pP]:\/\/|[hH][tT]{2}[pP][sS]:\/\/)(([A-Za-z0-9-~]+)\.)+([A-Za-z0-9-~\/])+.*$/;    if(!reg.test(id)){}else{window.location.replace("http://www.wmxz.wang/video.php?url="+id);}}</script><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">on</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> id=<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;ipt&#x27;</span>).value;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> url =<span class="hljs-string">&quot;http://www.wmxz.wang/video.php?url=&quot;</span>+id;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> reg=<span class="hljs-regexp">/^([hH][tT]&#123;2&#125;[pP]:\/\/|[hH][tT]&#123;2&#125;[pP][sS]:\/\/)(([A-Za-z0-9-~]+)\.)+([A-Za-z0-9-~\/])+.*$/</span>;</span><br>    if(!reg.test(id))&#123;<br><br><span class="javascript">&#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="javascript"><span class="hljs-built_in">window</span>.location.replace(<span class="hljs-string">&quot;http://www.wmxz.wang/video.php?url=&quot;</span>+id);</span><br>&#125;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>因为需要对输入的内容进行判断，这里采用了正则表达式进行匹配，正则表达式的用法非常多，这里只做简单</p><p>的用法介绍</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">var reg=/^(<span class="hljs-comment">[hH]</span><span class="hljs-comment">[tT]</span>&#123;2&#125;<span class="hljs-comment">[pP]</span>:\/\/|<span class="hljs-comment">[hH]</span><span class="hljs-comment">[tT]</span>&#123;2&#125;<span class="hljs-comment">[pP]</span><span class="hljs-comment">[sS]</span>:\/\/)((<span class="hljs-comment">[A-Za-z0-9-~]</span>+)\.)+(<span class="hljs-comment">[A-Za-z0-9-~\/]</span>)+.*$/;<br>/*<br>这句就是对输入的内容进行匹配，关键在于是<span class="hljs-comment">[hH]</span><span class="hljs-comment">[tT]</span>&#123;2&#125;<span class="hljs-comment">[pP]</span>:\/\/|<span class="hljs-comment">[hH]</span><span class="hljs-comment">[tT]</span>&#123;2&#125;<span class="hljs-comment">[pP]</span><span class="hljs-comment">[sS]</span><br><br>用地球的语言来说就是，输入的内容满足 https://XXXX.XXX 或 http://XXXX.XXX 的格式<br><br>对于网站来说，一般还有接下来的路径，所以满足域名的条件只需在后面进行贪婪匹配就完事了<br><br>*/<br><br></code></pre></td></tr></table></figure><p>最后再写亿点人人都会的css，就完成了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>.ipt&#123;<br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>; </span><br><span class="css">                <span class="hljs-attribute">padding</span>: <span class="hljs-number">7px</span> <span class="hljs-number">0px</span>;</span><br><span class="css">                <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;</span><br><span class="css"><span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;</span><br><span class="css">                <span class="hljs-attribute">padding</span>: <span class="hljs-number">7px</span> <span class="hljs-number">0px</span>;</span><br><span class="css">                <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;</span><br><span class="css">                <span class="hljs-attribute">padding-left</span>:<span class="hljs-number">5px</span>;</span><br><span class="css">                -webkit-<span class="hljs-attribute">box-shadow</span>: inset <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,.<span class="hljs-number">075</span>);</span><br><span class="css">                <span class="hljs-attribute">box-shadow</span>: inset <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,.<span class="hljs-number">075</span>);</span><br><span class="css">                -webkit-<span class="hljs-attribute">transition</span>: border-color ease-in-out .<span class="hljs-number">15s</span>,-webkit-box-shadow ease-in-out .<span class="hljs-number">15s</span>;</span><br><span class="css">                -o-<span class="hljs-attribute">transition</span>: border-color ease-in-out .<span class="hljs-number">15s</span>,box-shadow ease-in-out .<span class="hljs-number">15s</span>;</span><br><span class="css">                <span class="hljs-attribute">transition</span>: border-color ease-in-out .<span class="hljs-number">15s</span>,box-shadow ease-in-out .<span class="hljs-number">15s</span></span><br><span class="css"><span class="hljs-attribute">border-color</span>: <span class="hljs-number">#66afe9</span>;</span><br><span class="css">                    <span class="hljs-attribute">outline</span>: <span class="hljs-number">0</span>;</span><br><span class="css">                    -webkit-<span class="hljs-attribute">box-shadow</span>: inset <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,.<span class="hljs-number">075</span>),<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">8px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">102</span>,<span class="hljs-number">175</span>,<span class="hljs-number">233</span>,.<span class="hljs-number">6</span>);</span><br><span class="css">                    <span class="hljs-attribute">box-shadow</span>: inset <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,.<span class="hljs-number">075</span>),<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">8px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">102</span>,<span class="hljs-number">175</span>,<span class="hljs-number">233</span>,.<span class="hljs-number">6</span>)</span><br><span class="css">                <span class="hljs-attribute">padding-left</span>:<span class="hljs-number">5px</span>;</span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客新一年,新年快乐！</title>
    <link href="/2021/02/06/2021%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/"/>
    <url>/2021/02/06/2021%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原神拜年祭</p></blockquote><iframe src="//player.bilibili.com/player.html?aid=416575036&bvid=BV1FV411i7ok&cid=293566868&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="min-height:600px;width:100%;height:100%;"> </iframe><blockquote><p>结尾祝语</p></blockquote><p>新年快乐多多祝:</p><pre><code class="hljs">祈愿不保底圣遗物词条顺原石多又多</code></pre><p>大家都要赶上11号的拜年祭，同时别忘了支付宝五福开奖哦！</p><p>新年快乐，感谢陪伴！🙂</p>]]></content>
    
    
    <categories>
      
      <category>娱乐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
